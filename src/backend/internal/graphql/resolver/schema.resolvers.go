package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/internal/domain"
	"backend/internal/graphql/generated"
	"backend/internal/graphql/model"
	"backend/internal/logger"
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
)

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, userID string, file graphql.Upload) (model.UploadFileResponse, error) {
	r.log.Info("File upload started",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage
	_, err = r.storage.Upload(ctx, storageKey, file.File, file.Size, file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload file to storage",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Create reference letter record with pending status
	refLetter := &domain.ReferenceLetter{
		ID:     uuid.New(),
		UserID: uid,
		FileID: &fileID,
		Status: domain.ReferenceLetterStatusPending,
	}

	if err := r.refLetterRepo.Create(ctx, refLetter); err != nil {
		r.log.Error("Failed to create reference letter record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create reference letter record: %w", err)
	}

	// Enqueue document processing job
	if r.jobEnqueuer != nil {
		if enqueueErr := r.jobEnqueuer.EnqueueDocumentProcessing(ctx, domain.DocumentProcessingRequest{
			ReferenceLetterID: refLetter.ID,
			FileID:            fileID,
			StorageKey:        storageKey,
			ContentType:       file.ContentType,
		}); enqueueErr != nil {
			r.log.Error("Failed to enqueue document processing",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("file_id", fileID.String()),
				logger.String("reference_letter_id", refLetter.ID.String()),
				logger.Err(enqueueErr),
			)
			return nil, fmt.Errorf("failed to enqueue document processing: %w", enqueueErr)
		}
	}

	r.log.Info("File upload completed",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("reference_letter_id", refLetter.ID.String()),
		logger.String("storage_key", storageKey),
	)

	// Build response
	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(domainFile, gqlUser)
	gqlRefLetter := toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile)

	return &model.UploadFileResult{
		File:            gqlFile,
		ReferenceLetter: gqlRefLetter,
	}, nil
}

// UploadResume is the resolver for the uploadResume field.
func (r *mutationResolver) UploadResume(ctx context.Context, userID string, file graphql.Upload) (model.UploadResumeResponse, error) {
	r.log.Info("Resume upload started",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage
	_, err = r.storage.Upload(ctx, storageKey, file.File, file.Size, file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload file to storage",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Create resume record with pending status
	resume := &domain.Resume{
		ID:     uuid.New(),
		UserID: uid,
		FileID: fileID,
		Status: domain.ResumeStatusPending,
	}

	if err := r.resumeRepo.Create(ctx, resume); err != nil {
		r.log.Error("Failed to create resume record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create resume record: %w", err)
	}

	// Enqueue resume processing job
	if r.jobEnqueuer != nil {
		if enqueueErr := r.jobEnqueuer.EnqueueResumeProcessing(ctx, domain.ResumeProcessingRequest{
			ResumeID:    resume.ID,
			FileID:      fileID,
			StorageKey:  storageKey,
			ContentType: file.ContentType,
		}); enqueueErr != nil {
			r.log.Error("Failed to enqueue resume processing",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("file_id", fileID.String()),
				logger.String("resume_id", resume.ID.String()),
				logger.Err(enqueueErr),
			)
			return nil, fmt.Errorf("failed to enqueue resume processing: %w", enqueueErr)
		}
	}

	r.log.Info("Resume upload completed",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("resume_id", resume.ID.String()),
		logger.String("storage_key", storageKey),
	)

	// Build response
	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(domainFile, gqlUser)
	gqlResume := toGraphQLResume(resume, gqlUser, gqlFile)

	return &model.UploadResumeResult{
		File:   gqlFile,
		Resume: gqlResume,
	}, nil
}

// CreateExperience is the resolver for the createExperience field.
func (r *mutationResolver) CreateExperience(ctx context.Context, userID string, input model.CreateExperienceInput) (model.ExperienceResponse, error) {
	r.log.Info("Creating work experience",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ExperienceValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ExperienceValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileExpRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Convert highlights
	var highlights []string
	if input.Highlights != nil {
		highlights = input.Highlights
	}

	// Create experience
	experience := &domain.ProfileExperience{
		ID:           uuid.New(),
		ProfileID:    profile.ID,
		Company:      input.Company,
		Title:        input.Title,
		Location:     input.Location,
		StartDate:    input.StartDate,
		EndDate:      input.EndDate,
		IsCurrent:    input.IsCurrent,
		Description:  input.Description,
		Highlights:   highlights,
		DisplayOrder: displayOrder,
		Source:       domain.ExperienceSourceManual,
	}

	if err := r.profileExpRepo.Create(ctx, experience); err != nil {
		r.log.Error("Failed to create experience",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create experience: %w", err)
	}

	r.log.Info("Work experience created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("experience_id", experience.ID.String()),
	)

	return &model.ExperienceResult{
		Experience: toGraphQLProfileExperience(experience),
	}, nil
}

// UpdateExperience is the resolver for the updateExperience field.
func (r *mutationResolver) UpdateExperience(ctx context.Context, id string, input model.UpdateExperienceInput) (model.ExperienceResponse, error) {
	r.log.Info("Updating work experience",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	// Parse and validate experience ID
	expID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid experience ID format",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.ExperienceValidationError{
			Message: "invalid experience ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing experience
	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		r.log.Error("Failed to get experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		r.log.Warning("Experience not found",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.ExperienceValidationError{
			Message: "experience not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Company != nil {
		experience.Company = *input.Company
	}
	if input.Title != nil {
		experience.Title = *input.Title
	}
	if input.Location != nil {
		experience.Location = input.Location
	}
	if input.StartDate != nil {
		experience.StartDate = input.StartDate
	}
	if input.EndDate != nil {
		experience.EndDate = input.EndDate
	}
	if input.IsCurrent != nil {
		experience.IsCurrent = *input.IsCurrent
	}
	if input.Description != nil {
		experience.Description = input.Description
	}
	if input.Highlights != nil {
		experience.Highlights = input.Highlights
	}

	if err := r.profileExpRepo.Update(ctx, experience); err != nil {
		r.log.Error("Failed to update experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update experience: %w", err)
	}

	r.log.Info("Work experience updated",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	return &model.ExperienceResult{
		Experience: toGraphQLProfileExperience(experience),
	}, nil
}

// DeleteExperience is the resolver for the deleteExperience field.
func (r *mutationResolver) DeleteExperience(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting work experience",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	// Parse and validate experience ID
	expID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid experience ID format",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if experience exists
	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		r.log.Error("Failed to get experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		r.log.Warning("Experience not found",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete experience
	if err := r.profileExpRepo.Delete(ctx, expID); err != nil {
		r.log.Error("Failed to delete experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete experience: %w", err)
	}

	r.log.Info("Work experience deleted",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// CreateEducation is the resolver for the createEducation field.
func (r *mutationResolver) CreateEducation(ctx context.Context, userID string, input model.CreateEducationInput) (model.EducationResponse, error) {
	r.log.Info("Creating education entry",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.EducationValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.EducationValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileEduRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Create education entry
	education := &domain.ProfileEducation{
		ID:           uuid.New(),
		ProfileID:    profile.ID,
		Institution:  input.Institution,
		Degree:       input.Degree,
		Field:        input.Field,
		StartDate:    input.StartDate,
		EndDate:      input.EndDate,
		IsCurrent:    input.IsCurrent,
		Description:  input.Description,
		GPA:          input.Gpa,
		DisplayOrder: displayOrder,
		Source:       domain.ExperienceSourceManual,
	}

	if err := r.profileEduRepo.Create(ctx, education); err != nil {
		r.log.Error("Failed to create education",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create education: %w", err)
	}

	r.log.Info("Education entry created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("education_id", education.ID.String()),
	)

	return &model.EducationResult{
		Education: toGraphQLProfileEducation(education),
	}, nil
}

// UpdateEducation is the resolver for the updateEducation field.
func (r *mutationResolver) UpdateEducation(ctx context.Context, id string, input model.UpdateEducationInput) (model.EducationResponse, error) {
	r.log.Info("Updating education entry",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	// Parse and validate education ID
	eduID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid education ID format",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.EducationValidationError{
			Message: "invalid education ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing education
	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		r.log.Error("Failed to get education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		r.log.Warning("Education not found",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.EducationValidationError{
			Message: "education not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Institution != nil {
		education.Institution = *input.Institution
	}
	if input.Degree != nil {
		education.Degree = *input.Degree
	}
	if input.Field != nil {
		education.Field = input.Field
	}
	if input.StartDate != nil {
		education.StartDate = input.StartDate
	}
	if input.EndDate != nil {
		education.EndDate = input.EndDate
	}
	if input.IsCurrent != nil {
		education.IsCurrent = *input.IsCurrent
	}
	if input.Description != nil {
		education.Description = input.Description
	}
	if input.Gpa != nil {
		education.GPA = input.Gpa
	}

	if err := r.profileEduRepo.Update(ctx, education); err != nil {
		r.log.Error("Failed to update education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update education: %w", err)
	}

	r.log.Info("Education entry updated",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	return &model.EducationResult{
		Education: toGraphQLProfileEducation(education),
	}, nil
}

// DeleteEducation is the resolver for the deleteEducation field.
func (r *mutationResolver) DeleteEducation(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting education entry",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	// Parse and validate education ID
	eduID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid education ID format",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if education exists
	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		r.log.Error("Failed to get education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		r.log.Warning("Education not found",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete education
	if err := r.profileEduRepo.Delete(ctx, eduID); err != nil {
		r.log.Error("Failed to delete education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete education: %w", err)
	}

	r.log.Info("Education entry deleted",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// CreateSkill is the resolver for the createSkill field.
func (r *mutationResolver) CreateSkill(ctx context.Context, userID string, input model.CreateSkillInput) (model.SkillResponse, error) {
	r.log.Info("Creating skill",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.SkillValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Validate skill name
	if strings.TrimSpace(input.Name) == "" {
		return &model.SkillValidationError{
			Message: "skill name is required",
			Field:   stringPtr("name"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.SkillValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileSkillRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Create skill
	skill := &domain.ProfileSkill{
		ID:             uuid.New(),
		ProfileID:      profile.ID,
		Name:           input.Name,
		NormalizedName: normalizeSkillName(input.Name),
		Category:       strings.ToUpper(string(input.Category)),
		DisplayOrder:   displayOrder,
		Source:         domain.ExperienceSourceManual,
	}

	if err := r.profileSkillRepo.Create(ctx, skill); err != nil {
		r.log.Error("Failed to create skill",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create skill: %w", err)
	}

	r.log.Info("Skill created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("skill_id", skill.ID.String()),
	)

	return &model.SkillResult{
		Skill: toGraphQLProfileSkill(skill),
	}, nil
}

// UpdateSkill is the resolver for the updateSkill field.
func (r *mutationResolver) UpdateSkill(ctx context.Context, id string, input model.UpdateSkillInput) (model.SkillResponse, error) {
	r.log.Info("Updating skill",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	// Parse and validate skill ID
	skillID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid skill ID format",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.SkillValidationError{
			Message: "invalid skill ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing skill
	skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
	if err != nil {
		r.log.Error("Failed to get skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get skill: %w", err)
	}
	if skill == nil {
		r.log.Warning("Skill not found",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.SkillValidationError{
			Message: "skill not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Name != nil {
		skill.Name = *input.Name
		skill.NormalizedName = normalizeSkillName(*input.Name)
	}
	if input.Category != nil {
		skill.Category = strings.ToUpper(string(*input.Category))
	}

	if err := r.profileSkillRepo.Update(ctx, skill); err != nil {
		r.log.Error("Failed to update skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update skill: %w", err)
	}

	r.log.Info("Skill updated",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	return &model.SkillResult{
		Skill: toGraphQLProfileSkill(skill),
	}, nil
}

// DeleteSkill is the resolver for the deleteSkill field.
func (r *mutationResolver) DeleteSkill(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting skill",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	// Parse and validate skill ID
	skillID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid skill ID format",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if skill exists
	skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
	if err != nil {
		r.log.Error("Failed to get skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get skill: %w", err)
	}
	if skill == nil {
		r.log.Warning("Skill not found",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete skill
	if err := r.profileSkillRepo.Delete(ctx, skillID); err != nil {
		r.log.Error("Failed to delete skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete skill: %w", err)
	}

	r.log.Info("Skill deleted",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// ApplyReferenceLetterValidations is the resolver for the applyReferenceLetterValidations field.
func (r *mutationResolver) ApplyReferenceLetterValidations(ctx context.Context, userID string, input model.ApplyValidationsInput) (model.ApplyValidationsResponse, error) {
	r.log.Info("Applying reference letter validations",
		logger.Feature("credibility"),
		logger.String("user_id", userID),
		logger.String("reference_letter_id", input.ReferenceLetterID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
		)
		return &model.ApplyValidationsError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Parse and validate reference letter ID
	refLetterID, err := uuid.Parse(input.ReferenceLetterID)
	if err != nil {
		r.log.Warning("Invalid reference letter ID format",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
		)
		return &model.ApplyValidationsError{
			Message: "invalid reference letter ID format",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
		)
		return &model.ApplyValidationsError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get reference letter and verify it belongs to user
	refLetter, err := r.refLetterRepo.GetByID(ctx, refLetterID)
	if err != nil {
		r.log.Error("Failed to get reference letter",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}
	if refLetter == nil {
		r.log.Warning("Reference letter not found",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
		)
		return &model.ApplyValidationsError{
			Message: "reference letter not found",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}
	if refLetter.UserID != uid {
		r.log.Warning("Reference letter does not belong to user",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
			logger.String("reference_letter_id", input.ReferenceLetterID),
		)
		return &model.ApplyValidationsError{
			Message: "reference letter does not belong to user",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}

	// Reference letter must be completed or applied for validations to be applied
	// (allowing re-application of validations with different selections)
	if refLetter.Status != domain.ReferenceLetterStatusCompleted && refLetter.Status != domain.ReferenceLetterStatusApplied {
		r.log.Warning("Reference letter not completed",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
			logger.String("status", string(refLetter.Status)),
		)
		return &model.ApplyValidationsError{
			Message: "reference letter extraction not completed",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}

	// Parse extracted data to get author info for testimonials
	var extractedData domain.ExtractedLetterData
	if len(refLetter.ExtractedData) > 0 && string(refLetter.ExtractedData) != jsonNull {
		if jsonErr := json.Unmarshal(refLetter.ExtractedData, &extractedData); jsonErr != nil {
			r.log.Error("Failed to parse extracted data",
				logger.Feature("credibility"),
				logger.String("reference_letter_id", input.ReferenceLetterID),
				logger.Err(jsonErr),
			)
			return &model.ApplyValidationsError{
				Message: "failed to parse reference letter extracted data",
				Field:   stringPtr("referenceLetterID"),
			}, nil
		}
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Track applied counts
	appliedCount := &model.AppliedCount{}

	// Apply skill validations
	for _, sv := range input.SkillValidations {
		skillID, parseErr := uuid.Parse(sv.ProfileSkillID)
		if parseErr != nil {
			r.log.Warning("Invalid profile skill ID, skipping",
				logger.Feature("credibility"),
				logger.String("profile_skill_id", sv.ProfileSkillID),
			)
			continue
		}

		// Verify skill exists
		skill, skillErr := r.profileSkillRepo.GetByID(ctx, skillID)
		if skillErr != nil {
			r.log.Error("Failed to verify skill",
				logger.Feature("credibility"),
				logger.String("profile_skill_id", sv.ProfileSkillID),
				logger.Err(skillErr),
			)
			continue
		}
		if skill == nil {
			r.log.Warning("Skill not found, skipping",
				logger.Feature("credibility"),
				logger.String("profile_skill_id", sv.ProfileSkillID),
			)
			continue
		}

		// Create skill validation
		validation := &domain.SkillValidation{
			ID:                uuid.New(),
			ProfileSkillID:    skillID,
			ReferenceLetterID: refLetterID,
			QuoteSnippet:      &sv.QuoteSnippet,
		}

		if createErr := r.skillValidationRepo.Create(ctx, validation); createErr != nil {
			// Ignore duplicate constraint errors (upsert behavior)
			if !strings.Contains(createErr.Error(), "duplicate") && !strings.Contains(createErr.Error(), "unique constraint") {
				r.log.Error("Failed to create skill validation",
					logger.Feature("credibility"),
					logger.String("profile_skill_id", sv.ProfileSkillID),
					logger.Err(createErr),
				)
			}
			continue
		}
		appliedCount.SkillValidations++
	}

	// Apply experience validations
	for _, ev := range input.ExperienceValidations {
		expID, parseErr := uuid.Parse(ev.ProfileExperienceID)
		if parseErr != nil {
			r.log.Warning("Invalid profile experience ID, skipping",
				logger.Feature("credibility"),
				logger.String("profile_experience_id", ev.ProfileExperienceID),
			)
			continue
		}

		// Verify experience exists
		exp, expErr := r.profileExpRepo.GetByID(ctx, expID)
		if expErr != nil {
			r.log.Error("Failed to verify experience",
				logger.Feature("credibility"),
				logger.String("profile_experience_id", ev.ProfileExperienceID),
				logger.Err(expErr),
			)
			continue
		}
		if exp == nil {
			r.log.Warning("Experience not found, skipping",
				logger.Feature("credibility"),
				logger.String("profile_experience_id", ev.ProfileExperienceID),
			)
			continue
		}

		// Create experience validation
		validation := &domain.ExperienceValidation{
			ID:                  uuid.New(),
			ProfileExperienceID: expID,
			ReferenceLetterID:   refLetterID,
			QuoteSnippet:        &ev.QuoteSnippet,
		}

		if createErr := r.expValidationRepo.Create(ctx, validation); createErr != nil {
			// Ignore duplicate constraint errors (upsert behavior)
			if !strings.Contains(createErr.Error(), "duplicate") && !strings.Contains(createErr.Error(), "unique constraint") {
				r.log.Error("Failed to create experience validation",
					logger.Feature("credibility"),
					logger.String("profile_experience_id", ev.ProfileExperienceID),
					logger.Err(createErr),
				)
			}
			continue
		}
		appliedCount.ExperienceValidations++
	}

	// Create testimonials
	for _, ti := range input.Testimonials {
		// Map author relationship from extracted data to testimonial relationship
		relationship := mapAuthorToTestimonialRelationship(extractedData.Author.Relationship)

		testimonial := &domain.Testimonial{
			ID:                uuid.New(),
			ProfileID:         profile.ID,
			ReferenceLetterID: refLetterID,
			Quote:             ti.Quote,
			AuthorName:        extractedData.Author.Name,
			AuthorTitle:       extractedData.Author.Title,
			AuthorCompany:     extractedData.Author.Company,
			Relationship:      relationship,
		}

		if createErr := r.testimonialRepo.Create(ctx, testimonial); createErr != nil {
			r.log.Error("Failed to create testimonial",
				logger.Feature("credibility"),
				logger.String("profile_id", profile.ID.String()),
				logger.Err(createErr),
			)
			continue
		}
		appliedCount.Testimonials++
	}

	// Create new skills discovered in the reference letter
	for _, ns := range input.NewSkills {
		// Get next display order
		displayOrder, orderErr := r.profileSkillRepo.GetNextDisplayOrder(ctx, profile.ID)
		if orderErr != nil {
			r.log.Error("Failed to get next display order for skill",
				logger.Feature("credibility"),
				logger.String("profile_id", profile.ID.String()),
				logger.Err(orderErr),
			)
			continue
		}

		skill := &domain.ProfileSkill{
			ID:             uuid.New(),
			ProfileID:      profile.ID,
			Name:           ns.Name,
			NormalizedName: normalizeSkillName(ns.Name),
			Category:       strings.ToUpper(string(ns.Category)),
			DisplayOrder:   displayOrder,
			Source:         domain.ExperienceSourceManual,
		}

		if createErr := r.profileSkillRepo.Create(ctx, skill); createErr != nil {
			// Ignore duplicate skills (same normalized name)
			if !strings.Contains(createErr.Error(), "duplicate") && !strings.Contains(createErr.Error(), "unique constraint") {
				r.log.Error("Failed to create new skill",
					logger.Feature("credibility"),
					logger.String("skill_name", ns.Name),
					logger.Err(createErr),
				)
			}
			continue
		}

		// If quoteContext provided, also create a skill validation for it
		if ns.QuoteContext != nil && *ns.QuoteContext != "" {
			validation := &domain.SkillValidation{
				ID:                uuid.New(),
				ProfileSkillID:    skill.ID,
				ReferenceLetterID: refLetterID,
				QuoteSnippet:      ns.QuoteContext,
			}
			if valErr := r.skillValidationRepo.Create(ctx, validation); valErr != nil {
				r.log.Warning("Failed to create validation for new skill",
					logger.Feature("credibility"),
					logger.String("skill_id", skill.ID.String()),
					logger.Err(valErr),
				)
			}
		}
		appliedCount.NewSkills++
	}

	// Update reference letter status to applied
	refLetter.Status = domain.ReferenceLetterStatusApplied
	if updateErr := r.refLetterRepo.Update(ctx, refLetter); updateErr != nil {
		r.log.Error("Failed to update reference letter status",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
			logger.Err(updateErr),
		)
		// Continue anyway - validations were applied successfully
	}

	r.log.Info("Applied reference letter validations",
		logger.Feature("credibility"),
		logger.String("user_id", userID),
		logger.String("reference_letter_id", input.ReferenceLetterID),
		logger.Int("skill_validations", appliedCount.SkillValidations),
		logger.Int("experience_validations", appliedCount.ExperienceValidations),
		logger.Int("testimonials", appliedCount.Testimonials),
		logger.Int("new_skills", appliedCount.NewSkills),
	)

	// Fetch file for reference letter (may be nil)
	var file *model.File
	if refLetter.FileID != nil {
		fileEntity, fileErr := r.fileRepo.GetByID(ctx, *refLetter.FileID)
		if fileErr == nil && fileEntity != nil {
			file = toGraphQLFile(fileEntity, toGraphQLUser(user))
		}
	}

	// Fetch profile relations for response
	experiences, _ := r.profileExpRepo.GetByProfileID(ctx, profile.ID)
	educations, _ := r.profileEduRepo.GetByProfileID(ctx, profile.ID)
	skills, _ := r.profileSkillRepo.GetByProfileID(ctx, profile.ID)

	return &model.ApplyValidationsResult{
		ReferenceLetter: toGraphQLReferenceLetter(refLetter, toGraphQLUser(user), file),
		Profile:         toGraphQLProfile(profile, toGraphQLUser(user), toGraphQLProfileExperiences(experiences), toGraphQLProfileEducations(educations), toGraphQLProfileSkills(skills)),
		AppliedCount:    appliedCount,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	fid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID: %w", err)
	}

	file, err := r.fileRepo.GetByID(ctx, fid)
	if err != nil {
		return nil, fmt.Errorf("failed to get file: %w", err)
	}

	if file == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, file.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for file: %w", err)
	}

	return toGraphQLFile(file, toGraphQLUser(user)), nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, userID string) ([]*model.File, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	files, err := r.fileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get files: %w", err)
	}

	// Fetch the user once for all files
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for files: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	result := make([]*model.File, len(files))
	for i, f := range files {
		result[i] = toGraphQLFile(f, gqlUser)
	}

	return result, nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *queryResolver) ReferenceLetter(ctx context.Context, id string) (*model.ReferenceLetter, error) {
	lid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid reference letter ID: %w", err)
	}

	letter, err := r.refLetterRepo.GetByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}

	if letter == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, letter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letter: %w", err)
	}

	// Fetch the file relation if present
	var gqlFile *model.File
	if letter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *letter.FileID)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		gqlFile = toGraphQLFile(file, toGraphQLUser(user))
	}

	return toGraphQLReferenceLetter(letter, toGraphQLUser(user), gqlFile), nil
}

// ReferenceLetters is the resolver for the referenceLetters field.
func (r *queryResolver) ReferenceLetters(ctx context.Context, userID string) ([]*model.ReferenceLetter, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	letters, err := r.refLetterRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letters: %w", err)
	}

	// Fetch the user once for all letters
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letters: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, l := range letters {
		if l.FileID != nil {
			fileIDs[*l.FileID] = true
		}
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.ReferenceLetter, len(letters))
	for i, l := range letters {
		var gqlFile *model.File
		if l.FileID != nil {
			gqlFile = fileMap[*l.FileID]
		}
		result[i] = toGraphQLReferenceLetter(l, gqlUser, gqlFile)
	}

	return result, nil
}

// Resume is the resolver for the resume field.
func (r *queryResolver) Resume(ctx context.Context, id string) (*model.Resume, error) {
	rid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid resume ID: %w", err)
	}

	resume, err := r.resumeRepo.GetByID(ctx, rid)
	if err != nil {
		return nil, fmt.Errorf("failed to get resume: %w", err)
	}

	if resume == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, resume.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for resume: %w", err)
	}

	// Fetch the file relation
	file, err := r.fileRepo.GetByID(ctx, resume.FileID)
	if err != nil {
		return nil, fmt.Errorf("failed to get file for resume: %w", err)
	}

	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(file, gqlUser)

	return toGraphQLResume(resume, gqlUser, gqlFile), nil
}

// Resumes is the resolver for the resumes field.
func (r *queryResolver) Resumes(ctx context.Context, userID string) ([]*model.Resume, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	resumes, err := r.resumeRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get resumes: %w", err)
	}

	// Fetch the user once for all resumes
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for resumes: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, res := range resumes {
		fileIDs[res.FileID] = true
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for resume: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.Resume, len(resumes))
	for i, res := range resumes {
		gqlFile := fileMap[res.FileID]
		result[i] = toGraphQLResume(res, gqlUser, gqlFile)
	}

	return result, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context, userID string) (*model.Profile, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get the profile
	profile, err := r.profileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile: %w", err)
	}
	if profile == nil {
		return nil, nil
	}

	// Fetch the user
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for profile: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Fetch experiences
	experiences, err := r.profileExpRepo.GetByProfileID(ctx, profile.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get experiences for profile: %w", err)
	}
	gqlExperiences := toGraphQLProfileExperiences(experiences)

	// Fetch educations
	educations, err := r.profileEduRepo.GetByProfileID(ctx, profile.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get educations for profile: %w", err)
	}
	gqlEducations := toGraphQLProfileEducations(educations)

	// Fetch skills
	skills, err := r.profileSkillRepo.GetByProfileID(ctx, profile.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get skills for profile: %w", err)
	}
	gqlSkills := toGraphQLProfileSkills(skills)

	return toGraphQLProfile(profile, gqlUser, gqlExperiences, gqlEducations, gqlSkills), nil
}

// ProfileExperience is the resolver for the profileExperience field.
func (r *queryResolver) ProfileExperience(ctx context.Context, id string) (*model.ProfileExperience, error) {
	expID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid experience ID: %w", err)
	}

	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		return nil, nil
	}

	return toGraphQLProfileExperience(experience), nil
}

// ProfileEducation is the resolver for the profileEducation field.
func (r *queryResolver) ProfileEducation(ctx context.Context, id string) (*model.ProfileEducation, error) {
	eduID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid education ID: %w", err)
	}

	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		return nil, nil
	}

	return toGraphQLProfileEducation(education), nil
}

// ProfileSkill is the resolver for the profileSkill field.
func (r *queryResolver) ProfileSkill(ctx context.Context, id string) (*model.ProfileSkill, error) {
	skillID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid skill ID: %w", err)
	}

	skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
	if err != nil {
		return nil, fmt.Errorf("failed to get skill: %w", err)
	}
	if skill == nil {
		return nil, nil
	}

	return toGraphQLProfileSkill(skill), nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
