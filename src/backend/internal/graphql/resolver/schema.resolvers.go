package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/internal/domain"
	"backend/internal/graphql/generated"
	"backend/internal/graphql/model"
	"backend/internal/logger"
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
)

// Relationship is the resolver for the relationship field.
func (r *extractedAuthorResolver) Relationship(ctx context.Context, obj *model.ExtractedAuthor) (domain.AuthorRelationship, error) {
	panic(fmt.Errorf("not implemented: Relationship - relationship"))
}

// Strength is the resolver for the strength field.
func (r *extractedRecommendationResolver) Strength(ctx context.Context, obj *model.ExtractedRecommendation) (domain.RecommendationStrength, error) {
	panic(fmt.Errorf("not implemented: Strength - strength"))
}

// Category is the resolver for the category field.
func (r *extractedSkillResolver) Category(ctx context.Context, obj *model.ExtractedSkill) (domain.SkillCategory, error) {
	panic(fmt.Errorf("not implemented: Category - category"))
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, userID string, file graphql.Upload) (model.UploadFileResponse, error) {
	r.log.Info("File upload started",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage
	_, err = r.storage.Upload(ctx, storageKey, file.File, file.Size, file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload file to storage",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Create reference letter record with pending status
	refLetter := &domain.ReferenceLetter{
		ID:     uuid.New(),
		UserID: uid,
		FileID: &fileID,
		Status: domain.ReferenceLetterStatusPending,
	}

	if err := r.refLetterRepo.Create(ctx, refLetter); err != nil {
		r.log.Error("Failed to create reference letter record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create reference letter record: %w", err)
	}

	// Enqueue document processing job
	if r.jobEnqueuer != nil {
		if enqueueErr := r.jobEnqueuer.EnqueueDocumentProcessing(ctx, domain.DocumentProcessingRequest{
			ReferenceLetterID: refLetter.ID,
			FileID:            fileID,
			StorageKey:        storageKey,
		}); enqueueErr != nil {
			r.log.Error("Failed to enqueue document processing",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("file_id", fileID.String()),
				logger.String("reference_letter_id", refLetter.ID.String()),
				logger.Err(enqueueErr),
			)
			return nil, fmt.Errorf("failed to enqueue document processing: %w", enqueueErr)
		}
	}

	r.log.Info("File upload completed",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("reference_letter_id", refLetter.ID.String()),
		logger.String("storage_key", storageKey),
	)

	// Build response
	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(domainFile, gqlUser)
	gqlRefLetter := toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile)

	return &model.UploadFileResult{
		File:            gqlFile,
		ReferenceLetter: gqlRefLetter,
	}, nil
}

// UploadResume is the resolver for the uploadResume field.
func (r *mutationResolver) UploadResume(ctx context.Context, userID string, file graphql.Upload) (model.UploadResumeResponse, error) {
	r.log.Info("Resume upload started",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage
	_, err = r.storage.Upload(ctx, storageKey, file.File, file.Size, file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload file to storage",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Create resume record with pending status
	resume := &domain.Resume{
		ID:     uuid.New(),
		UserID: uid,
		FileID: fileID,
		Status: domain.ResumeStatusPending,
	}

	if err := r.resumeRepo.Create(ctx, resume); err != nil {
		r.log.Error("Failed to create resume record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create resume record: %w", err)
	}

	// Enqueue resume processing job
	if r.jobEnqueuer != nil {
		if enqueueErr := r.jobEnqueuer.EnqueueResumeProcessing(ctx, domain.ResumeProcessingRequest{
			ResumeID:    resume.ID,
			FileID:      fileID,
			StorageKey:  storageKey,
			ContentType: file.ContentType,
		}); enqueueErr != nil {
			r.log.Error("Failed to enqueue resume processing",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("file_id", fileID.String()),
				logger.String("resume_id", resume.ID.String()),
				logger.Err(enqueueErr),
			)
			return nil, fmt.Errorf("failed to enqueue resume processing: %w", enqueueErr)
		}
	}

	r.log.Info("Resume upload completed",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("resume_id", resume.ID.String()),
		logger.String("storage_key", storageKey),
	)

	// Build response
	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(domainFile, gqlUser)
	gqlResume := toGraphQLResume(resume, gqlUser, gqlFile)

	return &model.UploadResumeResult{
		File:   gqlFile,
		Resume: gqlResume,
	}, nil
}

// CreateExperience is the resolver for the createExperience field.
func (r *mutationResolver) CreateExperience(ctx context.Context, userID string, input model.CreateExperienceInput) (model.ExperienceResponse, error) {
	r.log.Info("Creating work experience",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ExperienceValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ExperienceValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileExpRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Convert highlights
	var highlights []string
	if input.Highlights != nil {
		highlights = input.Highlights
	}

	// Create experience
	experience := &domain.ProfileExperience{
		ID:           uuid.New(),
		ProfileID:    profile.ID,
		Company:      input.Company,
		Title:        input.Title,
		Location:     input.Location,
		StartDate:    input.StartDate,
		EndDate:      input.EndDate,
		IsCurrent:    input.IsCurrent,
		Description:  input.Description,
		Highlights:   highlights,
		DisplayOrder: displayOrder,
		Source:       domain.ExperienceSourceManual,
	}

	if err := r.profileExpRepo.Create(ctx, experience); err != nil {
		r.log.Error("Failed to create experience",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create experience: %w", err)
	}

	r.log.Info("Work experience created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("experience_id", experience.ID.String()),
	)

	return &model.ExperienceResult{
		Experience: toGraphQLProfileExperience(experience),
	}, nil
}

// UpdateExperience is the resolver for the updateExperience field.
func (r *mutationResolver) UpdateExperience(ctx context.Context, id string, input model.UpdateExperienceInput) (model.ExperienceResponse, error) {
	r.log.Info("Updating work experience",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	// Parse and validate experience ID
	expID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid experience ID format",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.ExperienceValidationError{
			Message: "invalid experience ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing experience
	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		r.log.Error("Failed to get experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		r.log.Warning("Experience not found",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.ExperienceValidationError{
			Message: "experience not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Company != nil {
		experience.Company = *input.Company
	}
	if input.Title != nil {
		experience.Title = *input.Title
	}
	if input.Location != nil {
		experience.Location = input.Location
	}
	if input.StartDate != nil {
		experience.StartDate = input.StartDate
	}
	if input.EndDate != nil {
		experience.EndDate = input.EndDate
	}
	if input.IsCurrent != nil {
		experience.IsCurrent = *input.IsCurrent
	}
	if input.Description != nil {
		experience.Description = input.Description
	}
	if input.Highlights != nil {
		experience.Highlights = input.Highlights
	}

	if err := r.profileExpRepo.Update(ctx, experience); err != nil {
		r.log.Error("Failed to update experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update experience: %w", err)
	}

	r.log.Info("Work experience updated",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	return &model.ExperienceResult{
		Experience: toGraphQLProfileExperience(experience),
	}, nil
}

// DeleteExperience is the resolver for the deleteExperience field.
func (r *mutationResolver) DeleteExperience(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting work experience",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	// Parse and validate experience ID
	expID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid experience ID format",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if experience exists
	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		r.log.Error("Failed to get experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		r.log.Warning("Experience not found",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete experience
	if err := r.profileExpRepo.Delete(ctx, expID); err != nil {
		r.log.Error("Failed to delete experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete experience: %w", err)
	}

	r.log.Info("Work experience deleted",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// CreateEducation is the resolver for the createEducation field.
func (r *mutationResolver) CreateEducation(ctx context.Context, userID string, input model.CreateEducationInput) (model.EducationResponse, error) {
	r.log.Info("Creating education entry",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.EducationValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.EducationValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileEduRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Create education entry
	education := &domain.ProfileEducation{
		ID:           uuid.New(),
		ProfileID:    profile.ID,
		Institution:  input.Institution,
		Degree:       input.Degree,
		Field:        input.Field,
		StartDate:    input.StartDate,
		EndDate:      input.EndDate,
		IsCurrent:    input.IsCurrent,
		Description:  input.Description,
		GPA:          input.Gpa,
		DisplayOrder: displayOrder,
		Source:       domain.ExperienceSourceManual,
	}

	if err := r.profileEduRepo.Create(ctx, education); err != nil {
		r.log.Error("Failed to create education",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create education: %w", err)
	}

	r.log.Info("Education entry created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("education_id", education.ID.String()),
	)

	return &model.EducationResult{
		Education: toGraphQLProfileEducation(education),
	}, nil
}

// UpdateEducation is the resolver for the updateEducation field.
func (r *mutationResolver) UpdateEducation(ctx context.Context, id string, input model.UpdateEducationInput) (model.EducationResponse, error) {
	r.log.Info("Updating education entry",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	// Parse and validate education ID
	eduID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid education ID format",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.EducationValidationError{
			Message: "invalid education ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing education
	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		r.log.Error("Failed to get education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		r.log.Warning("Education not found",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.EducationValidationError{
			Message: "education not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Institution != nil {
		education.Institution = *input.Institution
	}
	if input.Degree != nil {
		education.Degree = *input.Degree
	}
	if input.Field != nil {
		education.Field = input.Field
	}
	if input.StartDate != nil {
		education.StartDate = input.StartDate
	}
	if input.EndDate != nil {
		education.EndDate = input.EndDate
	}
	if input.IsCurrent != nil {
		education.IsCurrent = *input.IsCurrent
	}
	if input.Description != nil {
		education.Description = input.Description
	}
	if input.Gpa != nil {
		education.GPA = input.Gpa
	}

	if err := r.profileEduRepo.Update(ctx, education); err != nil {
		r.log.Error("Failed to update education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update education: %w", err)
	}

	r.log.Info("Education entry updated",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	return &model.EducationResult{
		Education: toGraphQLProfileEducation(education),
	}, nil
}

// DeleteEducation is the resolver for the deleteEducation field.
func (r *mutationResolver) DeleteEducation(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting education entry",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	// Parse and validate education ID
	eduID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid education ID format",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if education exists
	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		r.log.Error("Failed to get education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		r.log.Warning("Education not found",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete education
	if err := r.profileEduRepo.Delete(ctx, eduID); err != nil {
		r.log.Error("Failed to delete education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete education: %w", err)
	}

	r.log.Info("Education entry deleted",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	fid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID: %w", err)
	}

	file, err := r.fileRepo.GetByID(ctx, fid)
	if err != nil {
		return nil, fmt.Errorf("failed to get file: %w", err)
	}

	if file == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, file.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for file: %w", err)
	}

	return toGraphQLFile(file, toGraphQLUser(user)), nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, userID string) ([]*model.File, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	files, err := r.fileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get files: %w", err)
	}

	// Fetch the user once for all files
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for files: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	result := make([]*model.File, len(files))
	for i, f := range files {
		result[i] = toGraphQLFile(f, gqlUser)
	}

	return result, nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *queryResolver) ReferenceLetter(ctx context.Context, id string) (*model.ReferenceLetter, error) {
	lid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid reference letter ID: %w", err)
	}

	letter, err := r.refLetterRepo.GetByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}

	if letter == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, letter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letter: %w", err)
	}

	// Fetch the file relation if present
	var gqlFile *model.File
	if letter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *letter.FileID)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		gqlFile = toGraphQLFile(file, toGraphQLUser(user))
	}

	return toGraphQLReferenceLetter(letter, toGraphQLUser(user), gqlFile), nil
}

// ReferenceLetters is the resolver for the referenceLetters field.
func (r *queryResolver) ReferenceLetters(ctx context.Context, userID string) ([]*model.ReferenceLetter, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	letters, err := r.refLetterRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letters: %w", err)
	}

	// Fetch the user once for all letters
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letters: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, l := range letters {
		if l.FileID != nil {
			fileIDs[*l.FileID] = true
		}
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.ReferenceLetter, len(letters))
	for i, l := range letters {
		var gqlFile *model.File
		if l.FileID != nil {
			gqlFile = fileMap[*l.FileID]
		}
		result[i] = toGraphQLReferenceLetter(l, gqlUser, gqlFile)
	}

	return result, nil
}

// Resume is the resolver for the resume field.
func (r *queryResolver) Resume(ctx context.Context, id string) (*model.Resume, error) {
	rid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid resume ID: %w", err)
	}

	resume, err := r.resumeRepo.GetByID(ctx, rid)
	if err != nil {
		return nil, fmt.Errorf("failed to get resume: %w", err)
	}

	if resume == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, resume.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for resume: %w", err)
	}

	// Fetch the file relation
	file, err := r.fileRepo.GetByID(ctx, resume.FileID)
	if err != nil {
		return nil, fmt.Errorf("failed to get file for resume: %w", err)
	}

	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(file, gqlUser)

	return toGraphQLResume(resume, gqlUser, gqlFile), nil
}

// Resumes is the resolver for the resumes field.
func (r *queryResolver) Resumes(ctx context.Context, userID string) ([]*model.Resume, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	resumes, err := r.resumeRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get resumes: %w", err)
	}

	// Fetch the user once for all resumes
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for resumes: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, res := range resumes {
		fileIDs[res.FileID] = true
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for resume: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.Resume, len(resumes))
	for i, res := range resumes {
		gqlFile := fileMap[res.FileID]
		result[i] = toGraphQLResume(res, gqlUser, gqlFile)
	}

	return result, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context, userID string) (*model.Profile, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get the profile
	profile, err := r.profileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile: %w", err)
	}
	if profile == nil {
		return nil, nil
	}

	// Fetch the user
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for profile: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Fetch experiences
	experiences, err := r.profileExpRepo.GetByProfileID(ctx, profile.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get experiences for profile: %w", err)
	}
	gqlExperiences := toGraphQLProfileExperiences(experiences)

	// Fetch educations
	educations, err := r.profileEduRepo.GetByProfileID(ctx, profile.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get educations for profile: %w", err)
	}
	gqlEducations := toGraphQLProfileEducations(educations)

	return toGraphQLProfile(profile, gqlUser, gqlExperiences, gqlEducations), nil
}

// ProfileExperience is the resolver for the profileExperience field.
func (r *queryResolver) ProfileExperience(ctx context.Context, id string) (*model.ProfileExperience, error) {
	expID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid experience ID: %w", err)
	}

	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		return nil, nil
	}

	return toGraphQLProfileExperience(experience), nil
}

// ProfileEducation is the resolver for the profileEducation field.
func (r *queryResolver) ProfileEducation(ctx context.Context, id string) (*model.ProfileEducation, error) {
	eduID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid education ID: %w", err)
	}

	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		return nil, nil
	}

	return toGraphQLProfileEducation(education), nil
}

// ExtractedAuthor returns generated.ExtractedAuthorResolver implementation.
func (r *Resolver) ExtractedAuthor() generated.ExtractedAuthorResolver {
	return &extractedAuthorResolver{r}
}

// ExtractedRecommendation returns generated.ExtractedRecommendationResolver implementation.
func (r *Resolver) ExtractedRecommendation() generated.ExtractedRecommendationResolver {
	return &extractedRecommendationResolver{r}
}

// ExtractedSkill returns generated.ExtractedSkillResolver implementation.
func (r *Resolver) ExtractedSkill() generated.ExtractedSkillResolver {
	return &extractedSkillResolver{r}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type extractedAuthorResolver struct{ *Resolver }
type extractedRecommendationResolver struct{ *Resolver }
type extractedSkillResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
