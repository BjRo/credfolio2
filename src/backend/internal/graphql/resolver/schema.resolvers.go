package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/internal/domain"
	"backend/internal/graphql/generated"
	"backend/internal/graphql/model"
	"context"
	"fmt"

	"github.com/google/uuid"
)

// Relationship is the resolver for the relationship field.
func (r *extractedAuthorResolver) Relationship(ctx context.Context, obj *model.ExtractedAuthor) (domain.AuthorRelationship, error) {
	panic(fmt.Errorf("not implemented: Relationship - relationship"))
}

// Strength is the resolver for the strength field.
func (r *extractedRecommendationResolver) Strength(ctx context.Context, obj *model.ExtractedRecommendation) (domain.RecommendationStrength, error) {
	panic(fmt.Errorf("not implemented: Strength - strength"))
}

// Category is the resolver for the category field.
func (r *extractedSkillResolver) Category(ctx context.Context, obj *model.ExtractedSkill) (domain.SkillCategory, error) {
	panic(fmt.Errorf("not implemented: Category - category"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	fid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID: %w", err)
	}

	file, err := r.fileRepo.GetByID(ctx, fid)
	if err != nil {
		return nil, fmt.Errorf("failed to get file: %w", err)
	}

	if file == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, file.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for file: %w", err)
	}

	return toGraphQLFile(file, toGraphQLUser(user)), nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, userID string) ([]*model.File, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	files, err := r.fileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get files: %w", err)
	}

	// Fetch the user once for all files
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for files: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	result := make([]*model.File, len(files))
	for i, f := range files {
		result[i] = toGraphQLFile(f, gqlUser)
	}

	return result, nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *queryResolver) ReferenceLetter(ctx context.Context, id string) (*model.ReferenceLetter, error) {
	lid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid reference letter ID: %w", err)
	}

	letter, err := r.refLetterRepo.GetByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}

	if letter == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, letter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letter: %w", err)
	}

	// Fetch the file relation if present
	var gqlFile *model.File
	if letter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *letter.FileID)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		gqlFile = toGraphQLFile(file, toGraphQLUser(user))
	}

	return toGraphQLReferenceLetter(letter, toGraphQLUser(user), gqlFile), nil
}

// ReferenceLetters is the resolver for the referenceLetters field.
func (r *queryResolver) ReferenceLetters(ctx context.Context, userID string) ([]*model.ReferenceLetter, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	letters, err := r.refLetterRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letters: %w", err)
	}

	// Fetch the user once for all letters
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letters: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, l := range letters {
		if l.FileID != nil {
			fileIDs[*l.FileID] = true
		}
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.ReferenceLetter, len(letters))
	for i, l := range letters {
		var gqlFile *model.File
		if l.FileID != nil {
			gqlFile = fileMap[*l.FileID]
		}
		result[i] = toGraphQLReferenceLetter(l, gqlUser, gqlFile)
	}

	return result, nil
}

// ExtractedAuthor returns generated.ExtractedAuthorResolver implementation.
func (r *Resolver) ExtractedAuthor() generated.ExtractedAuthorResolver {
	return &extractedAuthorResolver{r}
}

// ExtractedRecommendation returns generated.ExtractedRecommendationResolver implementation.
func (r *Resolver) ExtractedRecommendation() generated.ExtractedRecommendationResolver {
	return &extractedRecommendationResolver{r}
}

// ExtractedSkill returns generated.ExtractedSkillResolver implementation.
func (r *Resolver) ExtractedSkill() generated.ExtractedSkillResolver {
	return &extractedSkillResolver{r}
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type extractedAuthorResolver struct{ *Resolver }
type extractedRecommendationResolver struct{ *Resolver }
type extractedSkillResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
