package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/internal/domain"
	"backend/internal/graphql/generated"
	"backend/internal/graphql/model"
	"backend/internal/logger"
	"backend/internal/service"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
)

// Experience is the resolver for the experience field.
func (r *experienceValidationResolver) Experience(ctx context.Context, obj *model.ExperienceValidation) (*model.ProfileExperience, error) {
	validationID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid validation ID: %w", err)
	}

	validation, err := r.expValidationRepo.GetByID(ctx, validationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get experience validation: %w", err)
	}
	if validation == nil {
		return nil, nil
	}

	experience, err := r.profileExpRepo.GetByID(ctx, validation.ProfileExperienceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile experience: %w", err)
	}
	if experience == nil {
		return nil, nil
	}

	return toGraphQLProfileExperience(experience), nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *experienceValidationResolver) ReferenceLetter(ctx context.Context, obj *model.ExperienceValidation) (*model.ReferenceLetter, error) {
	validationID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid validation ID: %w", err)
	}

	validation, err := r.expValidationRepo.GetByID(ctx, validationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get experience validation: %w", err)
	}
	if validation == nil {
		return nil, nil
	}

	refLetter, err := r.refLetterRepo.GetByID(ctx, validation.ReferenceLetterID)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}
	if refLetter == nil {
		return nil, nil
	}

	// Get the user for the reference letter
	user, err := r.userRepo.GetByID(ctx, refLetter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Get the file if present
	var gqlFile *model.File
	if refLetter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *refLetter.FileID)
		if err == nil && file != nil {
			gqlFile = toGraphQLFile(file, gqlUser)
		}
	}

	return toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile), nil
}

// URL is the resolver for the url field.
// It generates a presigned URL for downloading the file.
// Uses GetPresignedURL directly to ensure URLs expire (not permanent proxy URLs).
func (r *fileResolver) URL(ctx context.Context, obj *model.File) (string, error) {
	// Generate a presigned URL valid for 1 hour
	url, err := r.storage.GetPresignedURL(ctx, obj.StorageKey, time.Hour)
	if err != nil {
		r.log.Error("Failed to generate file URL",
			logger.Feature("file"),
			logger.String("file_id", obj.ID),
			logger.String("storage_key", obj.StorageKey),
			logger.Err(err),
		)
		return "", fmt.Errorf("failed to generate file URL: %w", err)
	}
	return url, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, userID string, file graphql.Upload, forceReimport *bool) (model.UploadFileResponse, error) {
	r.log.Info("File upload started",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Read file content and calculate hash for duplicate detection
	contentHash, fileContent, err := calculateContentHashFromReader(file.File)
	if err != nil {
		r.log.Error("Failed to read file content",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to read file content: %w", err)
	}

	r.log.Info("File content hash calculated",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("content_hash", contentHash),
	)

	// Check for duplicate file (unless forceReimport is true)
	if forceReimport == nil || !*forceReimport {
		existingFile, err := r.fileRepo.GetByUserIDAndContentHash(ctx, uid, contentHash)
		if err != nil {
			r.log.Error("Failed to check for duplicate file",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("content_hash", contentHash),
				logger.Err(err),
			)
			return nil, fmt.Errorf("failed to check for duplicate file: %w", err)
		}

		if existingFile != nil {
			r.log.Info("Duplicate file detected",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("content_hash", contentHash),
				logger.String("existing_file_id", existingFile.ID.String()),
			)

			// Find associated reference letter
			refLetters, err := r.refLetterRepo.GetByUserID(ctx, uid)
			if err != nil {
				r.log.Error("Failed to get reference letters",
					logger.Feature("upload"),
					logger.String("user_id", userID),
					logger.Err(err),
				)
				return nil, fmt.Errorf("failed to get reference letters: %w", err)
			}

			var existingRefLetter *domain.ReferenceLetter
			for _, rl := range refLetters {
				if rl.FileID != nil && *rl.FileID == existingFile.ID {
					existingRefLetter = rl
					break
				}
			}

			gqlUser := toGraphQLUser(user)
			gqlExistingFile := toGraphQLFile(existingFile, gqlUser)
			var gqlExistingRefLetter *model.ReferenceLetter
			if existingRefLetter != nil {
				gqlExistingRefLetter = toGraphQLReferenceLetter(existingRefLetter, gqlUser, gqlExistingFile)
			}

			return &model.DuplicateFileDetected{
				ExistingFile:            gqlExistingFile,
				ExistingReferenceLetter: gqlExistingRefLetter,
				Message:                 fmt.Sprintf("This document was already uploaded on %s.", existingFile.CreatedAt.Format("Jan 2, 2006")),
			}, nil
		}
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage (using bytes.Reader since we already read the content)
	_, err = r.storage.Upload(ctx, storageKey, bytes.NewReader(fileContent), int64(len(fileContent)), file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload file to storage",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record with content hash
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
		ContentHash: &contentHash,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Create reference letter record with pending status
	refLetter := &domain.ReferenceLetter{
		ID:     uuid.New(),
		UserID: uid,
		FileID: &fileID,
		Status: domain.ReferenceLetterStatusPending,
	}

	if err := r.refLetterRepo.Create(ctx, refLetter); err != nil {
		r.log.Error("Failed to create reference letter record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create reference letter record: %w", err)
	}

	// Enqueue document processing job
	if r.jobEnqueuer != nil {
		if enqueueErr := r.jobEnqueuer.EnqueueDocumentProcessing(ctx, domain.DocumentProcessingRequest{
			ReferenceLetterID: refLetter.ID,
			FileID:            fileID,
			StorageKey:        storageKey,
			ContentType:       file.ContentType,
		}); enqueueErr != nil {
			r.log.Error("Failed to enqueue document processing",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("file_id", fileID.String()),
				logger.String("reference_letter_id", refLetter.ID.String()),
				logger.Err(enqueueErr),
			)
			return nil, fmt.Errorf("failed to enqueue document processing: %w", enqueueErr)
		}
	}

	r.log.Info("File upload completed",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("reference_letter_id", refLetter.ID.String()),
		logger.String("storage_key", storageKey),
		logger.String("content_hash", contentHash),
	)

	// Build response
	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(domainFile, gqlUser)
	gqlRefLetter := toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile)

	return &model.UploadFileResult{
		File:            gqlFile,
		ReferenceLetter: gqlRefLetter,
	}, nil
}

// UploadResume is the resolver for the uploadResume field.
func (r *mutationResolver) UploadResume(ctx context.Context, userID string, file graphql.Upload, forceReimport *bool) (model.UploadResumeResponse, error) {
	r.log.Info("Resume upload started",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Read file content and calculate hash for duplicate detection
	contentHash, fileContent, err := calculateContentHashFromReader(file.File)
	if err != nil {
		r.log.Error("Failed to read file content",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to read file content: %w", err)
	}

	r.log.Info("Resume content hash calculated",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("content_hash", contentHash),
	)

	// Check for duplicate file (unless forceReimport is true)
	if forceReimport == nil || !*forceReimport {
		existingFile, err := r.fileRepo.GetByUserIDAndContentHash(ctx, uid, contentHash)
		if err != nil {
			r.log.Error("Failed to check for duplicate file",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("content_hash", contentHash),
				logger.Err(err),
			)
			return nil, fmt.Errorf("failed to check for duplicate file: %w", err)
		}

		if existingFile != nil {
			r.log.Info("Duplicate file detected for resume",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("content_hash", contentHash),
				logger.String("existing_file_id", existingFile.ID.String()),
			)

			// Find associated resume
			resumes, err := r.resumeRepo.GetByUserID(ctx, uid)
			if err != nil {
				r.log.Error("Failed to get resumes",
					logger.Feature("upload"),
					logger.String("user_id", userID),
					logger.Err(err),
				)
				return nil, fmt.Errorf("failed to get resumes: %w", err)
			}

			var existingResume *domain.Resume
			for _, res := range resumes {
				if res.FileID == existingFile.ID {
					existingResume = res
					break
				}
			}

			gqlUser := toGraphQLUser(user)
			gqlExistingFile := toGraphQLFile(existingFile, gqlUser)
			var gqlExistingResume *model.Resume
			if existingResume != nil {
				gqlExistingResume = toGraphQLResume(existingResume, gqlUser, gqlExistingFile)
			}

			return &model.DuplicateFileDetected{
				ExistingFile:   gqlExistingFile,
				ExistingResume: gqlExistingResume,
				Message:        fmt.Sprintf("This resume was already uploaded on %s.", existingFile.CreatedAt.Format("Jan 2, 2006")),
			}, nil
		}
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage (using bytes.Reader since we already read the content)
	_, err = r.storage.Upload(ctx, storageKey, bytes.NewReader(fileContent), int64(len(fileContent)), file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload file to storage",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record with content hash
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
		ContentHash: &contentHash,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Create resume record with pending status
	resume := &domain.Resume{
		ID:     uuid.New(),
		UserID: uid,
		FileID: fileID,
		Status: domain.ResumeStatusPending,
	}

	if err := r.resumeRepo.Create(ctx, resume); err != nil {
		r.log.Error("Failed to create resume record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create resume record: %w", err)
	}

	// Enqueue resume processing job
	if r.jobEnqueuer != nil {
		if enqueueErr := r.jobEnqueuer.EnqueueResumeProcessing(ctx, domain.ResumeProcessingRequest{
			ResumeID:    resume.ID,
			FileID:      fileID,
			StorageKey:  storageKey,
			ContentType: file.ContentType,
		}); enqueueErr != nil {
			r.log.Error("Failed to enqueue resume processing",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("file_id", fileID.String()),
				logger.String("resume_id", resume.ID.String()),
				logger.Err(enqueueErr),
			)
			return nil, fmt.Errorf("failed to enqueue resume processing: %w", enqueueErr)
		}
	}

	r.log.Info("Resume upload completed",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("resume_id", resume.ID.String()),
		logger.String("storage_key", storageKey),
		logger.String("content_hash", contentHash),
	)

	// Build response
	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(domainFile, gqlUser)
	gqlResume := toGraphQLResume(resume, gqlUser, gqlFile)

	return &model.UploadResumeResult{
		File:   gqlFile,
		Resume: gqlResume,
	}, nil
}

// UploadForDetection is the resolver for the uploadForDetection field.
func (r *mutationResolver) UploadForDetection(ctx context.Context, userID string, file graphql.Upload) (model.UploadForDetectionResponse, error) {
	r.log.Info("Upload for detection requested",
		logger.Feature("detection"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Validate user exists
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Read file content
	contentHash, fileContent, err := calculateContentHashFromReader(file.File)
	if err != nil {
		return nil, fmt.Errorf("failed to read file content: %w", err)
	}

	// Upload file to storage
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	_, err = r.storage.Upload(ctx, storageKey, bytes.NewReader(fileContent), int64(len(fileContent)), file.ContentType)
	if err != nil {
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record with detection_status = pending
	pendingStatus := domain.DetectionStatusPending
	domainFile := &domain.File{
		ID:              fileID,
		UserID:          uid,
		Filename:        file.Filename,
		ContentType:     file.ContentType,
		SizeBytes:       file.Size,
		StorageKey:      storageKey,
		ContentHash:     &contentHash,
		DetectionStatus: &pendingStatus,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Enqueue background detection job
	if err := r.jobEnqueuer.EnqueueDocumentDetection(ctx, domain.DocumentDetectionRequest{
		StorageKey:  storageKey,
		FileID:      fileID,
		ContentType: file.ContentType,
		UserID:      uid,
	}); err != nil {
		return nil, fmt.Errorf("failed to enqueue detection job: %w", err)
	}

	r.log.Info("File uploaded and detection job enqueued",
		logger.Feature("detection"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
	)

	return &model.UploadForDetectionResult{
		FileID: fileID.String(),
	}, nil
}

// ProcessDocument is the resolver for the processDocument field.
func (r *mutationResolver) ProcessDocument(ctx context.Context, userID string, input model.ProcessDocumentInput) (model.ProcessDocumentResponse, error) {
	r.log.Info("Process document requested",
		logger.Feature("document-processing"),
		logger.String("user_id", userID),
		logger.String("file_id", input.FileID),
		logger.Bool("extract_career_info", input.ExtractCareerInfo),
		logger.Bool("extract_testimonial", input.ExtractTestimonial),
	)

	// Validate at least one extraction type is requested
	if !input.ExtractCareerInfo && !input.ExtractTestimonial {
		return &model.ProcessDocumentError{
			Message: "at least one of extractCareerInfo or extractTestimonial must be true",
		}, nil
	}

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		return &model.ProcessDocumentError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		return &model.ProcessDocumentError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Parse and validate file ID
	fileID, err := uuid.Parse(input.FileID)
	if err != nil {
		return &model.ProcessDocumentError{
			Message: "invalid file ID format",
			Field:   stringPtr("fileId"),
		}, nil
	}

	// Verify file exists and belongs to user
	file, err := r.fileRepo.GetByID(ctx, fileID)
	if err != nil {
		return nil, fmt.Errorf("failed to get file: %w", err)
	}
	if file == nil {
		return &model.ProcessDocumentError{
			Message: "file not found",
			Field:   stringPtr("fileId"),
		}, nil
	}
	if file.UserID != uid {
		return &model.ProcessDocumentError{
			Message: "file does not belong to user",
			Field:   stringPtr("fileId"),
		}, nil
	}

	result := &model.ProcessDocumentResult{}
	var resumeID *uuid.UUID
	var refLetterID *uuid.UUID

	// Create resume record if career info extraction requested
	if input.ExtractCareerInfo {
		resume := &domain.Resume{
			ID:     uuid.New(),
			UserID: uid,
			FileID: fileID,
			Status: domain.ResumeStatusPending,
		}
		if err := r.resumeRepo.Create(ctx, resume); err != nil {
			return nil, fmt.Errorf("failed to create resume record: %w", err)
		}
		rid := resume.ID.String()
		result.ResumeID = &rid
		resumeID = &resume.ID
	}

	// Create reference letter record if testimonial extraction requested
	if input.ExtractTestimonial {
		refLetter := &domain.ReferenceLetter{
			ID:     uuid.New(),
			UserID: uid,
			FileID: &fileID,
			Status: domain.ReferenceLetterStatusPending,
		}
		if err := r.refLetterRepo.Create(ctx, refLetter); err != nil {
			return nil, fmt.Errorf("failed to create reference letter record: %w", err)
		}
		lid := refLetter.ID.String()
		result.ReferenceLetterID = &lid
		refLetterID = &refLetter.ID
	}

	// Enqueue the unified processing job
	if err := r.jobEnqueuer.EnqueueUnifiedDocumentProcessing(ctx, domain.UnifiedDocumentProcessingRequest{
		StorageKey:        file.StorageKey,
		FileID:            fileID,
		ContentType:       file.ContentType,
		UserID:            uid,
		ResumeID:          resumeID,
		ReferenceLetterID: refLetterID,
	}); err != nil {
		return nil, fmt.Errorf("failed to enqueue document processing: %w", err)
	}

	r.log.Info("Document processing enqueued",
		logger.Feature("document-processing"),
		logger.String("user_id", userID),
		logger.String("file_id", input.FileID),
	)

	return result, nil
}

// ImportDocumentResults is the resolver for the importDocumentResults field.
func (r *mutationResolver) ImportDocumentResults(ctx context.Context, userID string, input model.ImportDocumentResultsInput) (model.ImportDocumentResultsResponse, error) {
	r.log.Info("Import document results requested",
		logger.Feature("document-processing"),
		logger.String("user_id", userID),
	)

	// Validate at least one ID is provided
	if input.ResumeID == nil && input.ReferenceLetterID == nil {
		return &model.ImportDocumentResultsError{
			Message: "at least one of resumeId or referenceLetterID must be provided",
		}, nil
	}

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		return &model.ImportDocumentResultsError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		return &model.ImportDocumentResultsError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	imported := &model.ImportedCount{}

	// Track reference letter data for cross-referencing after both materializations
	var refLetterIDForXRef *uuid.UUID
	var refLetterDataForXRef *domain.ExtractedLetterData

	// Materialize resume data if resume ID is provided
	if input.ResumeID != nil {
		resumeID, err := uuid.Parse(*input.ResumeID)
		if err != nil {
			return &model.ImportDocumentResultsError{
				Message: "invalid resume ID format",
				Field:   stringPtr("resumeId"),
			}, nil
		}

		resume, err := r.resumeRepo.GetByID(ctx, resumeID)
		if err != nil {
			return nil, fmt.Errorf("failed to get resume: %w", err)
		}
		if resume == nil {
			return &model.ImportDocumentResultsError{
				Message: "resume not found",
				Field:   stringPtr("resumeId"),
			}, nil
		}
		if resume.UserID != uid {
			return &model.ImportDocumentResultsError{
				Message: "resume does not belong to user",
				Field:   stringPtr("resumeId"),
			}, nil
		}
		if resume.Status != domain.ResumeStatusCompleted {
			return &model.ImportDocumentResultsError{
				Message: fmt.Sprintf("resume is not ready for import (status: %s)", resume.Status),
				Field:   stringPtr("resumeId"),
			}, nil
		}

		// Parse extracted data
		var extractedData domain.ResumeExtractedData
		if err := json.Unmarshal(resume.ExtractedData, &extractedData); err != nil {
			return nil, fmt.Errorf("failed to parse extracted resume data: %w", err)
		}

		// Apply item-level selection filters (nil = import all)
		if input.SelectedExperienceIndices != nil {
			extractedData.Experience = service.FilterByIndices(extractedData.Experience, input.SelectedExperienceIndices)
		}
		if input.SelectedEducationIndices != nil {
			extractedData.Education = service.FilterByIndices(extractedData.Education, input.SelectedEducationIndices)
		}
		if input.SelectedSkills != nil {
			extractedData.Skills = service.FilterSkillsByName(extractedData.Skills, input.SelectedSkills)
		}

		// Materialize into profile tables
		matResult, err := r.materializationSvc.MaterializeResumeData(ctx, resumeID, uid, &extractedData)
		if err != nil {
			return nil, fmt.Errorf("failed to materialize resume data: %w", err)
		}

		imported.Experiences = matResult.Experiences
		imported.Educations = matResult.Educations
		imported.Skills = matResult.Skills

		r.log.Info("Resume data materialized",
			logger.Feature("document-processing"),
			logger.String("resume_id", resumeID.String()),
			logger.Int("experiences", matResult.Experiences),
			logger.Int("educations", matResult.Educations),
			logger.Int("skills", matResult.Skills),
		)
	}

	// Materialize reference letter data if reference letter ID is provided
	if input.ReferenceLetterID != nil {
		refLetterID, parseErr := uuid.Parse(*input.ReferenceLetterID)
		if parseErr != nil {
			return &model.ImportDocumentResultsError{
				Message: "invalid reference letter ID format",
				Field:   stringPtr("referenceLetterID"),
			}, nil
		}

		refLetter, getErr := r.refLetterRepo.GetByID(ctx, refLetterID)
		if getErr != nil {
			return nil, fmt.Errorf("failed to get reference letter: %w", getErr)
		}
		if refLetter == nil {
			return &model.ImportDocumentResultsError{
				Message: "reference letter not found",
				Field:   stringPtr("referenceLetterID"),
			}, nil
		}
		if refLetter.UserID != uid {
			return &model.ImportDocumentResultsError{
				Message: "reference letter does not belong to user",
				Field:   stringPtr("referenceLetterID"),
			}, nil
		}
		if refLetter.Status != domain.ReferenceLetterStatusCompleted {
			return &model.ImportDocumentResultsError{
				Message: fmt.Sprintf("reference letter is not ready for import (status: %s)", refLetter.Status),
				Field:   stringPtr("referenceLetterID"),
			}, nil
		}

		// Parse extracted data
		if len(refLetter.ExtractedData) > 0 && string(refLetter.ExtractedData) != jsonNull {
			var extractedData domain.ExtractedLetterData
			if jsonErr := json.Unmarshal(refLetter.ExtractedData, &extractedData); jsonErr != nil {
				return nil, fmt.Errorf("failed to parse extracted reference letter data: %w", jsonErr)
			}

			// Apply item-level selection filters (nil = import all)
			if input.SelectedTestimonialIndices != nil {
				extractedData.Testimonials = service.FilterByIndices(extractedData.Testimonials, input.SelectedTestimonialIndices)
			}
			if input.SelectedDiscoveredSkills != nil {
				selected := make([]service.SelectedDiscoveredSkill, len(input.SelectedDiscoveredSkills))
				for i, s := range input.SelectedDiscoveredSkills {
					selected[i] = service.SelectedDiscoveredSkill{
						Name:     s.Name,
						Category: s.Category,
					}
				}
				extractedData.DiscoveredSkills = service.FilterDiscoveredSkillsWithCategory(extractedData.DiscoveredSkills, selected)
			}

			// Materialize into profile tables
			matResult, matErr := r.materializationSvc.MaterializeReferenceLetterData(ctx, refLetterID, uid, &extractedData)
			if matErr != nil {
				return nil, fmt.Errorf("failed to materialize reference letter data: %w", matErr)
			}

			imported.Testimonials = matResult.Testimonials

			// Save for cross-referencing with resume skills/experiences
			refLetterIDForXRef = &refLetterID
			refLetterDataForXRef = &extractedData

			r.log.Info("Reference letter data materialized",
				logger.Feature("document-processing"),
				logger.String("reference_letter_id", refLetterID.String()),
				logger.Int("testimonials", matResult.Testimonials),
			)
		}
	}

	// Get or create the profile to return
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile: %w", err)
	}

	// Cross-reference reference letter mentions with profile skills/experiences
	if refLetterIDForXRef != nil && refLetterDataForXRef != nil {
		xrefResult, xrefErr := r.materializationSvc.CrossReferenceValidations(ctx, profile.ID, *refLetterIDForXRef, refLetterDataForXRef)
		if xrefErr != nil {
			r.log.Error("Failed to cross-reference validations",
				logger.Feature("document-processing"),
				logger.Err(xrefErr),
			)
			// Non-fatal â€” the import itself succeeded
		} else {
			r.log.Info("Cross-referenced validations",
				logger.Feature("document-processing"),
				logger.Int("skill_validations", xrefResult.SkillValidations),
				logger.Int("experience_validations", xrefResult.ExperienceValidations),
			)
		}
	}

	// Build profile response with current data
	gqlProfile := domainProfileToGQL(profile, nil)

	return &model.ImportDocumentResultsResult{
		Profile:       gqlProfile,
		ImportedCount: imported,
	}, nil
}

// ReportDocumentFeedback is the resolver for the reportDocumentFeedback field.
func (r *mutationResolver) ReportDocumentFeedback(ctx context.Context, userID string, input model.DocumentFeedbackInput) (*model.DocumentFeedbackResult, error) {
	// Parse user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		return &model.DocumentFeedbackResult{Success: false}, nil
	}

	// Parse file ID
	fileID, err := uuid.Parse(input.FileID)
	if err != nil {
		return &model.DocumentFeedbackResult{Success: false}, nil
	}

	// Map GraphQL enum to domain type
	var feedbackType domain.DocumentFeedbackType
	switch input.FeedbackType {
	case model.DocumentFeedbackTypeDetectionCorrection:
		feedbackType = domain.DocumentFeedbackDetectionCorrection
	case model.DocumentFeedbackTypeExtractionQuality:
		feedbackType = domain.DocumentFeedbackExtractionQuality
	default:
		feedbackType = domain.DocumentFeedbackType(input.FeedbackType.String())
	}

	// Log structured feedback (no table for MVP)
	r.log.Info("Document feedback reported",
		logger.Feature("document-feedback"),
		logger.String("user_id", uid.String()),
		logger.String("file_id", fileID.String()),
		logger.String("feedback_type", string(feedbackType)),
		logger.String("message", input.Message),
	)

	return &model.DocumentFeedbackResult{Success: true}, nil
}

// UpdateProfileHeader is the resolver for the updateProfileHeader field.
func (r *mutationResolver) UpdateProfileHeader(ctx context.Context, userID string, input model.UpdateProfileHeaderInput) (model.ProfileHeaderResponse, error) {
	r.log.Info("Updating profile header",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ProfileHeaderValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ProfileHeaderValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Validate email format if provided
	if input.Email != nil && *input.Email != "" {
		if !isValidEmail(*input.Email) {
			return &model.ProfileHeaderValidationError{
				Message: "invalid email format",
				Field:   stringPtr("email"),
			}, nil
		}
	}

	// Validate phone format if provided (basic validation)
	if input.Phone != nil && *input.Phone != "" {
		if !isValidPhone(*input.Phone) {
			return &model.ProfileHeaderValidationError{
				Message: "invalid phone format",
				Field:   stringPtr("phone"),
			}, nil
		}
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Update only fields that are provided
	if input.Name != nil {
		profile.Name = input.Name
	}
	if input.Email != nil {
		profile.Email = input.Email
	}
	if input.Phone != nil {
		profile.Phone = input.Phone
	}
	if input.Location != nil {
		profile.Location = input.Location
	}
	if input.Summary != nil {
		profile.Summary = input.Summary
	}

	// Persist the changes
	if err := r.profileRepo.Update(ctx, profile); err != nil {
		r.log.Error("Failed to update profile",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update profile: %w", err)
	}

	r.log.Info("Profile header updated successfully",
		logger.Feature("profile"),
		logger.String("profile_id", profile.ID.String()),
	)

	// Get photo URL if present
	var photoURL *string
	if profile.ProfilePhotoFileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *profile.ProfilePhotoFileID)
		if err == nil && file != nil {
			url, err := r.storage.GetPublicURL(ctx, file.StorageKey, 24*time.Hour)
			if err == nil {
				photoURL = &url
			}
		}
	}

	// Convert to GraphQL model
	gqlProfile := domainProfileToGQL(profile, photoURL)

	return &model.ProfileHeaderResult{
		Profile: gqlProfile,
	}, nil
}

// UploadProfilePhoto is the resolver for the uploadProfilePhoto field.
func (r *mutationResolver) UploadProfilePhoto(ctx context.Context, userID string, file graphql.Upload) (model.UploadProfilePhotoResponse, error) {
	r.log.Info("Profile photo upload started",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type (images only)
	allowedTypes := map[string]bool{
		"image/jpeg": true,
		"image/png":  true,
		"image/gif":  true,
		"image/webp": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed for profile photo",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be JPEG, PNG, GIF, or WebP",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 5MB for photos)
	const maxSize = 5 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large for profile photo",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 5MB",
			Field:   "size",
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Delete old photo file if exists
	if profile.ProfilePhotoFileID != nil {
		oldFile, err := r.fileRepo.GetByID(ctx, *profile.ProfilePhotoFileID)
		if err == nil && oldFile != nil {
			// Delete from storage (best effort)
			_ = r.storage.Delete(ctx, oldFile.StorageKey)
			// Delete file record (best effort)
			_ = r.fileRepo.Delete(ctx, *profile.ProfilePhotoFileID)
		}
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("profile-photos/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage
	_, err = r.storage.Upload(ctx, storageKey, file.File, file.Size, file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload profile photo to storage",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload profile photo to storage: %w", err)
	}

	// Create file record
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey)
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Update profile with new photo file ID
	profile.ProfilePhotoFileID = &fileID
	if err := r.profileRepo.Update(ctx, profile); err != nil {
		r.log.Error("Failed to update profile with photo",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update profile: %w", err)
	}

	r.log.Info("Profile photo uploaded successfully",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("storage_key", storageKey),
	)

	// Generate public URL for the photo
	photoURL, err := r.storage.GetPublicURL(ctx, storageKey, 24*time.Hour)
	if err != nil {
		r.log.Warning("Failed to generate public URL",
			logger.Feature("profile"),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		// Continue without the URL
		photoURL = ""
	}

	var photoURLPtr *string
	if photoURL != "" {
		photoURLPtr = &photoURL
	}

	// Convert to GraphQL model
	gqlProfile := domainProfileToGQL(profile, photoURLPtr)

	return &model.UploadProfilePhotoResult{
		Profile: gqlProfile,
	}, nil
}

// DeleteProfilePhoto is the resolver for the deleteProfilePhoto field.
func (r *mutationResolver) DeleteProfilePhoto(ctx context.Context, userID string) (model.DeleteProfilePhotoResponse, error) {
	r.log.Info("Profile photo deletion started",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ProfileHeaderValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get profile
	profile, err := r.profileRepo.GetByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get profile: %w", err)
	}
	if profile == nil {
		r.log.Warning("Profile not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ProfileHeaderValidationError{
			Message: "profile not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Check if there's a photo to delete
	if profile.ProfilePhotoFileID == nil {
		r.log.Info("No profile photo to delete",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.DeleteProfilePhotoResult{
			Success: true,
		}, nil
	}

	// Get the file record
	file, err := r.fileRepo.GetByID(ctx, *profile.ProfilePhotoFileID)
	if err != nil {
		r.log.Error("Failed to get file record",
			logger.Feature("profile"),
			logger.String("file_id", profile.ProfilePhotoFileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get file record: %w", err)
	}

	// Delete from storage
	if file != nil {
		if err := r.storage.Delete(ctx, file.StorageKey); err != nil {
			r.log.Warning("Failed to delete photo from storage",
				logger.Feature("profile"),
				logger.String("storage_key", file.StorageKey),
				logger.Err(err),
			)
			// Continue anyway - the file record will be deleted
		}
	}

	// Delete file record
	if err := r.fileRepo.Delete(ctx, *profile.ProfilePhotoFileID); err != nil {
		r.log.Error("Failed to delete file record",
			logger.Feature("profile"),
			logger.String("file_id", profile.ProfilePhotoFileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete file record: %w", err)
	}

	// Update profile to remove photo reference
	profile.ProfilePhotoFileID = nil
	if err := r.profileRepo.Update(ctx, profile); err != nil {
		r.log.Error("Failed to update profile",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update profile: %w", err)
	}

	r.log.Info("Profile photo deleted successfully",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	return &model.DeleteProfilePhotoResult{
		Success: true,
	}, nil
}

// CreateExperience is the resolver for the createExperience field.
func (r *mutationResolver) CreateExperience(ctx context.Context, userID string, input model.CreateExperienceInput) (model.ExperienceResponse, error) {
	r.log.Info("Creating work experience",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ExperienceValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.ExperienceValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileExpRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Convert highlights
	var highlights []string
	if input.Highlights != nil {
		highlights = input.Highlights
	}

	// Create experience
	experience := &domain.ProfileExperience{
		ID:           uuid.New(),
		ProfileID:    profile.ID,
		Company:      input.Company,
		Title:        input.Title,
		Location:     input.Location,
		StartDate:    input.StartDate,
		EndDate:      input.EndDate,
		IsCurrent:    input.IsCurrent,
		Description:  input.Description,
		Highlights:   highlights,
		DisplayOrder: displayOrder,
		Source:       domain.ExperienceSourceManual,
	}

	if err := r.profileExpRepo.Create(ctx, experience); err != nil {
		r.log.Error("Failed to create experience",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create experience: %w", err)
	}

	r.log.Info("Work experience created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("experience_id", experience.ID.String()),
	)

	return &model.ExperienceResult{
		Experience: toGraphQLProfileExperience(experience),
	}, nil
}

// UpdateExperience is the resolver for the updateExperience field.
func (r *mutationResolver) UpdateExperience(ctx context.Context, id string, input model.UpdateExperienceInput) (model.ExperienceResponse, error) {
	r.log.Info("Updating work experience",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	// Parse and validate experience ID
	expID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid experience ID format",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.ExperienceValidationError{
			Message: "invalid experience ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing experience
	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		r.log.Error("Failed to get experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		r.log.Warning("Experience not found",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.ExperienceValidationError{
			Message: "experience not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Company != nil {
		experience.Company = *input.Company
	}
	if input.Title != nil {
		experience.Title = *input.Title
	}
	if input.Location != nil {
		experience.Location = input.Location
	}
	if input.StartDate != nil {
		experience.StartDate = input.StartDate
	}
	if input.EndDate != nil {
		experience.EndDate = input.EndDate
	}
	if input.IsCurrent != nil {
		experience.IsCurrent = *input.IsCurrent
	}
	if input.Description != nil {
		experience.Description = input.Description
	}
	if input.Highlights != nil {
		experience.Highlights = input.Highlights
	}

	if err := r.profileExpRepo.Update(ctx, experience); err != nil {
		r.log.Error("Failed to update experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update experience: %w", err)
	}

	r.log.Info("Work experience updated",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	return &model.ExperienceResult{
		Experience: toGraphQLProfileExperience(experience),
	}, nil
}

// DeleteExperience is the resolver for the deleteExperience field.
func (r *mutationResolver) DeleteExperience(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting work experience",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	// Parse and validate experience ID
	expID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid experience ID format",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if experience exists
	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		r.log.Error("Failed to get experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		r.log.Warning("Experience not found",
			logger.Feature("profile"),
			logger.String("experience_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete experience
	if err := r.profileExpRepo.Delete(ctx, expID); err != nil {
		r.log.Error("Failed to delete experience",
			logger.Feature("profile"),
			logger.String("experience_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete experience: %w", err)
	}

	r.log.Info("Work experience deleted",
		logger.Feature("profile"),
		logger.String("experience_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// CreateEducation is the resolver for the createEducation field.
func (r *mutationResolver) CreateEducation(ctx context.Context, userID string, input model.CreateEducationInput) (model.EducationResponse, error) {
	r.log.Info("Creating education entry",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.EducationValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.EducationValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileEduRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Create education entry
	education := &domain.ProfileEducation{
		ID:           uuid.New(),
		ProfileID:    profile.ID,
		Institution:  input.Institution,
		Degree:       input.Degree,
		Field:        input.Field,
		StartDate:    input.StartDate,
		EndDate:      input.EndDate,
		IsCurrent:    input.IsCurrent,
		Description:  input.Description,
		GPA:          input.Gpa,
		DisplayOrder: displayOrder,
		Source:       domain.ExperienceSourceManual,
	}

	if err := r.profileEduRepo.Create(ctx, education); err != nil {
		r.log.Error("Failed to create education",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create education: %w", err)
	}

	r.log.Info("Education entry created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("education_id", education.ID.String()),
	)

	return &model.EducationResult{
		Education: toGraphQLProfileEducation(education),
	}, nil
}

// UpdateEducation is the resolver for the updateEducation field.
func (r *mutationResolver) UpdateEducation(ctx context.Context, id string, input model.UpdateEducationInput) (model.EducationResponse, error) {
	r.log.Info("Updating education entry",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	// Parse and validate education ID
	eduID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid education ID format",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.EducationValidationError{
			Message: "invalid education ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing education
	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		r.log.Error("Failed to get education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		r.log.Warning("Education not found",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.EducationValidationError{
			Message: "education not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Institution != nil {
		education.Institution = *input.Institution
	}
	if input.Degree != nil {
		education.Degree = *input.Degree
	}
	if input.Field != nil {
		education.Field = input.Field
	}
	if input.StartDate != nil {
		education.StartDate = input.StartDate
	}
	if input.EndDate != nil {
		education.EndDate = input.EndDate
	}
	if input.IsCurrent != nil {
		education.IsCurrent = *input.IsCurrent
	}
	if input.Description != nil {
		education.Description = input.Description
	}
	if input.Gpa != nil {
		education.GPA = input.Gpa
	}

	if err := r.profileEduRepo.Update(ctx, education); err != nil {
		r.log.Error("Failed to update education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update education: %w", err)
	}

	r.log.Info("Education entry updated",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	return &model.EducationResult{
		Education: toGraphQLProfileEducation(education),
	}, nil
}

// DeleteEducation is the resolver for the deleteEducation field.
func (r *mutationResolver) DeleteEducation(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting education entry",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	// Parse and validate education ID
	eduID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid education ID format",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if education exists
	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		r.log.Error("Failed to get education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		r.log.Warning("Education not found",
			logger.Feature("profile"),
			logger.String("education_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete education
	if err := r.profileEduRepo.Delete(ctx, eduID); err != nil {
		r.log.Error("Failed to delete education",
			logger.Feature("profile"),
			logger.String("education_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete education: %w", err)
	}

	r.log.Info("Education entry deleted",
		logger.Feature("profile"),
		logger.String("education_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// CreateSkill is the resolver for the createSkill field.
func (r *mutationResolver) CreateSkill(ctx context.Context, userID string, input model.CreateSkillInput) (model.SkillResponse, error) {
	r.log.Info("Creating skill",
		logger.Feature("profile"),
		logger.String("user_id", userID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.SkillValidationError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Validate skill name
	if strings.TrimSpace(input.Name) == "" {
		return &model.SkillValidationError{
			Message: "skill name is required",
			Field:   stringPtr("name"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("profile"),
			logger.String("user_id", userID),
		)
		return &model.SkillValidationError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("profile"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Get next display order
	displayOrder, err := r.profileSkillRepo.GetNextDisplayOrder(ctx, profile.ID)
	if err != nil {
		r.log.Error("Failed to get next display order",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get next display order: %w", err)
	}

	// Create skill
	skill := &domain.ProfileSkill{
		ID:             uuid.New(),
		ProfileID:      profile.ID,
		Name:           input.Name,
		NormalizedName: normalizeSkillName(input.Name),
		Category:       strings.ToUpper(string(input.Category)),
		DisplayOrder:   displayOrder,
		Source:         domain.ExperienceSourceManual,
	}

	if err := r.profileSkillRepo.Create(ctx, skill); err != nil {
		r.log.Error("Failed to create skill",
			logger.Feature("profile"),
			logger.String("profile_id", profile.ID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create skill: %w", err)
	}

	r.log.Info("Skill created",
		logger.Feature("profile"),
		logger.String("user_id", userID),
		logger.String("skill_id", skill.ID.String()),
	)

	return &model.SkillResult{
		Skill: toGraphQLProfileSkill(skill),
	}, nil
}

// UpdateSkill is the resolver for the updateSkill field.
func (r *mutationResolver) UpdateSkill(ctx context.Context, id string, input model.UpdateSkillInput) (model.SkillResponse, error) {
	r.log.Info("Updating skill",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	// Parse and validate skill ID
	skillID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid skill ID format",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.SkillValidationError{
			Message: "invalid skill ID format",
			Field:   stringPtr("id"),
		}, nil
	}

	// Get existing skill
	skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
	if err != nil {
		r.log.Error("Failed to get skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get skill: %w", err)
	}
	if skill == nil {
		r.log.Warning("Skill not found",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.SkillValidationError{
			Message: "skill not found",
			Field:   stringPtr("id"),
		}, nil
	}

	// Update fields if provided
	if input.Name != nil {
		skill.Name = *input.Name
		skill.NormalizedName = normalizeSkillName(*input.Name)
	}
	if input.Category != nil {
		skill.Category = strings.ToUpper(string(*input.Category))
	}

	if err := r.profileSkillRepo.Update(ctx, skill); err != nil {
		r.log.Error("Failed to update skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update skill: %w", err)
	}

	r.log.Info("Skill updated",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	return &model.SkillResult{
		Skill: toGraphQLProfileSkill(skill),
	}, nil
}

// DeleteSkill is the resolver for the deleteSkill field.
func (r *mutationResolver) DeleteSkill(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting skill",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	// Parse and validate skill ID
	skillID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid skill ID format",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if skill exists
	skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
	if err != nil {
		r.log.Error("Failed to get skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get skill: %w", err)
	}
	if skill == nil {
		r.log.Warning("Skill not found",
			logger.Feature("profile"),
			logger.String("skill_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete skill
	if err := r.profileSkillRepo.Delete(ctx, skillID); err != nil {
		r.log.Error("Failed to delete skill",
			logger.Feature("profile"),
			logger.String("skill_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete skill: %w", err)
	}

	r.log.Info("Skill deleted",
		logger.Feature("profile"),
		logger.String("skill_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// ApplyReferenceLetterValidations is the resolver for the applyReferenceLetterValidations field.
func (r *mutationResolver) ApplyReferenceLetterValidations(ctx context.Context, userID string, input model.ApplyValidationsInput) (model.ApplyValidationsResponse, error) {
	r.log.Info("Applying reference letter validations",
		logger.Feature("credibility"),
		logger.String("user_id", userID),
		logger.String("reference_letter_id", input.ReferenceLetterID),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
		)
		return &model.ApplyValidationsError{
			Message: "invalid user ID format",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Parse and validate reference letter ID
	refLetterID, err := uuid.Parse(input.ReferenceLetterID)
	if err != nil {
		r.log.Warning("Invalid reference letter ID format",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
		)
		return &model.ApplyValidationsError{
			Message: "invalid reference letter ID format",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
		)
		return &model.ApplyValidationsError{
			Message: "user not found",
			Field:   stringPtr("userId"),
		}, nil
	}

	// Get reference letter and verify it belongs to user
	refLetter, err := r.refLetterRepo.GetByID(ctx, refLetterID)
	if err != nil {
		r.log.Error("Failed to get reference letter",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}
	if refLetter == nil {
		r.log.Warning("Reference letter not found",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
		)
		return &model.ApplyValidationsError{
			Message: "reference letter not found",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}
	if refLetter.UserID != uid {
		r.log.Warning("Reference letter does not belong to user",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
			logger.String("reference_letter_id", input.ReferenceLetterID),
		)
		return &model.ApplyValidationsError{
			Message: "reference letter does not belong to user",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}

	// Reference letter must be completed or applied for validations to be applied
	// (allowing re-application of validations with different selections)
	if refLetter.Status != domain.ReferenceLetterStatusCompleted && refLetter.Status != domain.ReferenceLetterStatusApplied {
		r.log.Warning("Reference letter not completed",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
			logger.String("status", string(refLetter.Status)),
		)
		return &model.ApplyValidationsError{
			Message: "reference letter extraction not completed",
			Field:   stringPtr("referenceLetterID"),
		}, nil
	}

	// Parse extracted data to get author info for testimonials
	var extractedData domain.ExtractedLetterData
	if len(refLetter.ExtractedData) > 0 && string(refLetter.ExtractedData) != jsonNull {
		if jsonErr := json.Unmarshal(refLetter.ExtractedData, &extractedData); jsonErr != nil {
			r.log.Error("Failed to parse extracted data",
				logger.Feature("credibility"),
				logger.String("reference_letter_id", input.ReferenceLetterID),
				logger.Err(jsonErr),
			)
			return &model.ApplyValidationsError{
				Message: "failed to parse reference letter extracted data",
				Field:   stringPtr("referenceLetterID"),
			}, nil
		}
	}

	// Get or create profile for user
	profile, err := r.profileRepo.GetOrCreateByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get or create profile",
			logger.Feature("credibility"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get or create profile: %w", err)
	}

	// Track applied counts
	appliedCount := &model.AppliedCount{}

	// Apply skill validations
	for _, sv := range input.SkillValidations {
		skillID, parseErr := uuid.Parse(sv.ProfileSkillID)
		if parseErr != nil {
			r.log.Warning("Invalid profile skill ID, skipping",
				logger.Feature("credibility"),
				logger.String("profile_skill_id", sv.ProfileSkillID),
			)
			continue
		}

		// Verify skill exists
		skill, skillErr := r.profileSkillRepo.GetByID(ctx, skillID)
		if skillErr != nil {
			r.log.Error("Failed to verify skill",
				logger.Feature("credibility"),
				logger.String("profile_skill_id", sv.ProfileSkillID),
				logger.Err(skillErr),
			)
			continue
		}
		if skill == nil {
			r.log.Warning("Skill not found, skipping",
				logger.Feature("credibility"),
				logger.String("profile_skill_id", sv.ProfileSkillID),
			)
			continue
		}

		// Create skill validation
		validation := &domain.SkillValidation{
			ID:                uuid.New(),
			ProfileSkillID:    skillID,
			ReferenceLetterID: refLetterID,
			QuoteSnippet:      &sv.QuoteSnippet,
		}

		if createErr := r.skillValidationRepo.Create(ctx, validation); createErr != nil {
			// Ignore duplicate constraint errors (upsert behavior)
			if !strings.Contains(createErr.Error(), "duplicate") && !strings.Contains(createErr.Error(), "unique constraint") {
				r.log.Error("Failed to create skill validation",
					logger.Feature("credibility"),
					logger.String("profile_skill_id", sv.ProfileSkillID),
					logger.Err(createErr),
				)
			}
			continue
		}
		appliedCount.SkillValidations++
	}

	// Apply experience validations
	for _, ev := range input.ExperienceValidations {
		expID, parseErr := uuid.Parse(ev.ProfileExperienceID)
		if parseErr != nil {
			r.log.Warning("Invalid profile experience ID, skipping",
				logger.Feature("credibility"),
				logger.String("profile_experience_id", ev.ProfileExperienceID),
			)
			continue
		}

		// Verify experience exists
		exp, expErr := r.profileExpRepo.GetByID(ctx, expID)
		if expErr != nil {
			r.log.Error("Failed to verify experience",
				logger.Feature("credibility"),
				logger.String("profile_experience_id", ev.ProfileExperienceID),
				logger.Err(expErr),
			)
			continue
		}
		if exp == nil {
			r.log.Warning("Experience not found, skipping",
				logger.Feature("credibility"),
				logger.String("profile_experience_id", ev.ProfileExperienceID),
			)
			continue
		}

		// Create experience validation
		validation := &domain.ExperienceValidation{
			ID:                  uuid.New(),
			ProfileExperienceID: expID,
			ReferenceLetterID:   refLetterID,
			QuoteSnippet:        &ev.QuoteSnippet,
		}

		if createErr := r.expValidationRepo.Create(ctx, validation); createErr != nil {
			// Ignore duplicate constraint errors (upsert behavior)
			if !strings.Contains(createErr.Error(), "duplicate") && !strings.Contains(createErr.Error(), "unique constraint") {
				r.log.Error("Failed to create experience validation",
					logger.Feature("credibility"),
					logger.String("profile_experience_id", ev.ProfileExperienceID),
					logger.Err(createErr),
				)
			}
			continue
		}
		appliedCount.ExperienceValidations++
	}

	// Create testimonials
	// First, find or create the Author entity for all testimonials from this reference letter
	var author *domain.Author
	if len(input.Testimonials) > 0 {
		// Try to find existing author with same name and company
		existingAuthor, findErr := r.authorRepo.FindByNameAndCompany(ctx, profile.ID, extractedData.Author.Name, extractedData.Author.Company)
		if findErr != nil {
			r.log.Error("Failed to find existing author",
				logger.Feature("credibility"),
				logger.String("profile_id", profile.ID.String()),
				logger.Err(findErr),
			)
		}

		if existingAuthor != nil {
			author = existingAuthor
		} else {
			// Create new author
			author = &domain.Author{
				ProfileID: profile.ID,
				Name:      extractedData.Author.Name,
				Title:     extractedData.Author.Title,
				Company:   extractedData.Author.Company,
			}
			if createErr := r.authorRepo.Create(ctx, author); createErr != nil {
				r.log.Error("Failed to create author",
					logger.Feature("credibility"),
					logger.String("profile_id", profile.ID.String()),
					logger.Err(createErr),
				)
			}
		}
	}

	for _, ti := range input.Testimonials {
		// Map author relationship from extracted data to testimonial relationship
		relationship := mapAuthorToTestimonialRelationship(extractedData.Author.Relationship)

		testimonial := &domain.Testimonial{
			ID:                uuid.New(),
			ProfileID:         profile.ID,
			ReferenceLetterID: refLetterID,
			Quote:             ti.Quote,
			Relationship:      relationship,
			SkillsMentioned:   ti.SkillsMentioned,
		}

		// Link to author if created successfully
		if author != nil {
			testimonial.AuthorID = &author.ID
		}

		// Also populate legacy fields for backward compatibility
		testimonial.AuthorName = &extractedData.Author.Name
		testimonial.AuthorTitle = extractedData.Author.Title
		testimonial.AuthorCompany = extractedData.Author.Company

		if createErr := r.testimonialRepo.Create(ctx, testimonial); createErr != nil {
			r.log.Error("Failed to create testimonial",
				logger.Feature("credibility"),
				logger.String("profile_id", profile.ID.String()),
				logger.Err(createErr),
			)
			continue
		}
		appliedCount.Testimonials++
	}

	// Create new skills discovered in the reference letter
	for _, ns := range input.NewSkills {
		// Get next display order
		displayOrder, orderErr := r.profileSkillRepo.GetNextDisplayOrder(ctx, profile.ID)
		if orderErr != nil {
			r.log.Error("Failed to get next display order for skill",
				logger.Feature("credibility"),
				logger.String("profile_id", profile.ID.String()),
				logger.Err(orderErr),
			)
			continue
		}

		skill := &domain.ProfileSkill{
			ID:                      uuid.New(),
			ProfileID:               profile.ID,
			Name:                    ns.Name,
			NormalizedName:          normalizeSkillName(ns.Name),
			Category:                strings.ToUpper(string(ns.Category)),
			DisplayOrder:            displayOrder,
			Source:                  domain.ExperienceSourceLetterDiscovered,
			SourceReferenceLetterID: &refLetterID,
		}

		if createErr := r.profileSkillRepo.Create(ctx, skill); createErr != nil {
			// Ignore duplicate skills (same normalized name)
			if !strings.Contains(createErr.Error(), "duplicate") && !strings.Contains(createErr.Error(), "unique constraint") {
				r.log.Error("Failed to create new skill",
					logger.Feature("credibility"),
					logger.String("skill_name", ns.Name),
					logger.Err(createErr),
				)
			}
			continue
		}

		// If quoteContext provided, also create a skill validation for it
		if ns.QuoteContext != nil && *ns.QuoteContext != "" {
			validation := &domain.SkillValidation{
				ID:                uuid.New(),
				ProfileSkillID:    skill.ID,
				ReferenceLetterID: refLetterID,
				QuoteSnippet:      ns.QuoteContext,
			}
			if valErr := r.skillValidationRepo.Create(ctx, validation); valErr != nil {
				r.log.Warning("Failed to create validation for new skill",
					logger.Feature("credibility"),
					logger.String("skill_id", skill.ID.String()),
					logger.Err(valErr),
				)
			}
		}
		appliedCount.NewSkills++
	}

	// Update reference letter status to applied
	refLetter.Status = domain.ReferenceLetterStatusApplied
	if updateErr := r.refLetterRepo.Update(ctx, refLetter); updateErr != nil {
		r.log.Error("Failed to update reference letter status",
			logger.Feature("credibility"),
			logger.String("reference_letter_id", input.ReferenceLetterID),
			logger.Err(updateErr),
		)
		// Continue anyway - validations were applied successfully
	}

	r.log.Info("Applied reference letter validations",
		logger.Feature("credibility"),
		logger.String("user_id", userID),
		logger.String("reference_letter_id", input.ReferenceLetterID),
		logger.Int("skill_validations", appliedCount.SkillValidations),
		logger.Int("experience_validations", appliedCount.ExperienceValidations),
		logger.Int("testimonials", appliedCount.Testimonials),
		logger.Int("new_skills", appliedCount.NewSkills),
	)

	// Fetch file for reference letter (may be nil)
	var file *model.File
	if refLetter.FileID != nil {
		fileEntity, fileErr := r.fileRepo.GetByID(ctx, *refLetter.FileID)
		if fileErr == nil && fileEntity != nil {
			file = toGraphQLFile(fileEntity, toGraphQLUser(user))
		}
	}

	// Fetch profile relations for response
	experiences, _ := r.profileExpRepo.GetByProfileID(ctx, profile.ID)
	educations, _ := r.profileEduRepo.GetByProfileID(ctx, profile.ID)
	skills, _ := r.profileSkillRepo.GetByProfileID(ctx, profile.ID)

	// Get photo URL if present
	var photoURL *string
	if profile.ProfilePhotoFileID != nil {
		photoFile, fileErr := r.fileRepo.GetByID(ctx, *profile.ProfilePhotoFileID)
		if fileErr == nil && photoFile != nil {
			url, urlErr := r.storage.GetPublicURL(ctx, photoFile.StorageKey, 24*time.Hour)
			if urlErr == nil {
				photoURL = &url
			}
		}
	}

	return &model.ApplyValidationsResult{
		ReferenceLetter: toGraphQLReferenceLetter(refLetter, toGraphQLUser(user), file),
		Profile:         toGraphQLProfile(profile, toGraphQLUser(user), toGraphQLProfileExperiences(experiences), toGraphQLProfileEducations(educations), toGraphQLProfileSkills(skills), photoURL),
		AppliedCount:    appliedCount,
	}, nil
}

// UploadAuthorImage is the resolver for the uploadAuthorImage field.
func (r *mutationResolver) UploadAuthorImage(ctx context.Context, authorID string, file graphql.Upload) (model.UploadAuthorImageResponse, error) {
	r.log.Info("Author image upload started",
		logger.Feature("profile"),
		logger.String("author_id", authorID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate author ID
	aid, err := uuid.Parse(authorID)
	if err != nil {
		r.log.Warning("Invalid author ID format",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
		)
		return &model.FileValidationError{
			Message: "invalid author ID format",
			Field:   "authorId",
		}, nil
	}

	// Get existing author to verify it exists
	author, err := r.authorRepo.GetByID(ctx, aid)
	if err != nil {
		r.log.Error("Failed to get author",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get author: %w", err)
	}
	if author == nil {
		r.log.Warning("Author not found",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
		)
		return &model.FileValidationError{
			Message: "author not found",
			Field:   "authorId",
		}, nil
	}

	// Validate file type (images only)
	allowedTypes := map[string]bool{
		"image/jpeg": true,
		"image/png":  true,
		"image/gif":  true,
		"image/webp": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed for author image",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be JPEG, PNG, GIF, or WebP",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 5MB for photos)
	const maxSize = 5 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large for author image",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 5MB",
			Field:   "size",
		}, nil
	}

	// Delete old image file if exists
	if author.ImageID != nil {
		oldFile, err := r.fileRepo.GetByID(ctx, *author.ImageID)
		if err == nil && oldFile != nil {
			// Delete from storage (best effort)
			_ = r.storage.Delete(ctx, oldFile.StorageKey)
			// Delete file record (best effort)
			_ = r.fileRepo.Delete(ctx, *author.ImageID)
		}
	}

	// Generate storage key - use profile ID for organization
	fileID := uuid.New()
	storageKey := fmt.Sprintf("author-images/%s/%s/%s", author.ProfileID.String(), fileID.String(), file.Filename)

	// Upload to storage
	_, err = r.storage.Upload(ctx, storageKey, file.File, file.Size, file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload author image to storage",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload author image to storage: %w", err)
	}

	// Get the profile's user ID for file record
	profile, err := r.profileRepo.GetByID(ctx, author.ProfileID)
	if err != nil {
		r.log.Error("Failed to get profile for author",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.String("profile_id", author.ProfileID.String()),
			logger.Err(err),
		)
		// Clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey)
		return nil, fmt.Errorf("failed to get profile: %w", err)
	}

	// Create file record
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      profile.UserID,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey)
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Update author with new image ID
	author.ImageID = &fileID
	if err := r.authorRepo.Update(ctx, author); err != nil {
		r.log.Error("Failed to update author with image",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to update author: %w", err)
	}

	// Generate presigned URL for the response
	imageURL, err := r.storage.GetPresignedURL(ctx, storageKey, time.Hour)
	if err != nil {
		r.log.Warning("Failed to generate presigned URL for author image",
			logger.Feature("profile"),
			logger.String("author_id", authorID),
			logger.Err(err),
		)
		// Continue without URL - not a fatal error
	}

	// Get user for file response
	user, err := r.userRepo.GetByID(ctx, profile.UserID)
	if err != nil {
		r.log.Warning("Failed to get user for file response",
			logger.Feature("profile"),
			logger.String("user_id", profile.UserID.String()),
			logger.Err(err),
		)
	}

	r.log.Info("Author image uploaded successfully",
		logger.Feature("profile"),
		logger.String("author_id", authorID),
		logger.String("file_id", fileID.String()),
	)

	return &model.UploadAuthorImageResult{
		File:   toGraphQLFile(domainFile, toGraphQLUser(user)),
		Author: toGraphQLAuthorWithImage(author, &imageURL),
	}, nil
}

// UpdateAuthor is the resolver for the updateAuthor field.
func (r *mutationResolver) UpdateAuthor(ctx context.Context, id string, input model.UpdateAuthorInput) (*model.Author, error) {
	authorID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid author ID: %w", err)
	}

	// Get existing author
	author, err := r.authorRepo.GetByID(ctx, authorID)
	if err != nil {
		return nil, fmt.Errorf("failed to get author: %w", err)
	}
	if author == nil {
		return nil, fmt.Errorf("author not found")
	}

	// Apply updates
	if input.Name != nil {
		author.Name = *input.Name
	}
	if input.Title != nil {
		if *input.Title == "" {
			author.Title = nil
		} else {
			author.Title = input.Title
		}
	}
	if input.Company != nil {
		if *input.Company == "" {
			author.Company = nil
		} else {
			author.Company = input.Company
		}
	}
	if input.LinkedInURL != nil {
		if *input.LinkedInURL == "" {
			author.LinkedInURL = nil
		} else {
			author.LinkedInURL = input.LinkedInURL
		}
	}
	if input.ImageID != nil {
		if *input.ImageID == "" {
			// Clear the image
			author.ImageID = nil
		} else {
			imageUUID, err := uuid.Parse(*input.ImageID)
			if err != nil {
				return nil, fmt.Errorf("invalid image ID: %w", err)
			}
			author.ImageID = &imageUUID
		}
	}

	// Save updates
	if err := r.authorRepo.Update(ctx, author); err != nil {
		return nil, fmt.Errorf("failed to update author: %w", err)
	}

	// Get image URL if author has an image
	var imageURL *string
	if author.ImageID != nil {
		file, err := r.fileRepo.GetByID(ctx, *author.ImageID)
		if err == nil && file != nil {
			url, err := r.storage.GetPresignedURL(ctx, file.StorageKey, time.Hour)
			if err == nil {
				imageURL = &url
			}
		}
	}

	return toGraphQLAuthorWithImage(author, imageURL), nil
}

// DeleteTestimonial is the resolver for the deleteTestimonial field.
func (r *mutationResolver) DeleteTestimonial(ctx context.Context, id string) (*model.DeleteResult, error) {
	r.log.Info("Deleting testimonial",
		logger.Feature("profile"),
		logger.String("testimonial_id", id),
	)

	// Parse and validate testimonial ID
	testimonialID, err := uuid.Parse(id)
	if err != nil {
		r.log.Warning("Invalid testimonial ID format",
			logger.Feature("profile"),
			logger.String("testimonial_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Check if testimonial exists
	testimonial, err := r.testimonialRepo.GetByID(ctx, testimonialID)
	if err != nil {
		r.log.Error("Failed to get testimonial",
			logger.Feature("profile"),
			logger.String("testimonial_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get testimonial: %w", err)
	}
	if testimonial == nil {
		r.log.Warning("Testimonial not found",
			logger.Feature("profile"),
			logger.String("testimonial_id", id),
		)
		return &model.DeleteResult{
			Success:   false,
			DeletedID: id,
		}, nil
	}

	// Delete testimonial
	if err := r.testimonialRepo.Delete(ctx, testimonialID); err != nil {
		r.log.Error("Failed to delete testimonial",
			logger.Feature("profile"),
			logger.String("testimonial_id", id),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to delete testimonial: %w", err)
	}

	r.log.Info("Testimonial deleted",
		logger.Feature("profile"),
		logger.String("testimonial_id", id),
	)

	return &model.DeleteResult{
		Success:   true,
		DeletedID: id,
	}, nil
}

// Testimonials is the resolver for the testimonials field.
func (r *profileResolver) Testimonials(ctx context.Context, obj *model.Profile) ([]*model.Testimonial, error) {
	profileID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid profile ID: %w", err)
	}

	testimonials, err := r.testimonialRepo.GetByProfileID(ctx, profileID)
	if err != nil {
		return nil, fmt.Errorf("failed to load testimonials: %w", err)
	}

	// Convert domain testimonials to GraphQL model
	// The nested fields (author, referenceLetter, validatedSkills) are resolved
	// by their respective field resolvers in gqlgen
	result := make([]*model.Testimonial, len(testimonials))
	for i, t := range testimonials {
		var relationship model.TestimonialRelationship
		switch t.Relationship {
		case domain.TestimonialRelationshipManager:
			relationship = model.TestimonialRelationshipManager
		case domain.TestimonialRelationshipPeer:
			relationship = model.TestimonialRelationshipPeer
		case domain.TestimonialRelationshipDirectReport:
			relationship = model.TestimonialRelationshipDirectReport
		case domain.TestimonialRelationshipClient:
			relationship = model.TestimonialRelationshipClient
		default:
			relationship = model.TestimonialRelationshipOther
		}

		authorName := ""
		if t.AuthorName != nil {
			authorName = *t.AuthorName
		}

		result[i] = &model.Testimonial{
			ID:            t.ID.String(),
			Quote:         t.Quote,
			AuthorName:    authorName,
			AuthorTitle:   t.AuthorTitle,
			AuthorCompany: t.AuthorCompany,
			Relationship:  relationship,
			CreatedAt:     t.CreatedAt,
			// These fields will be resolved by their field resolvers:
			// - Author (via testimonialResolver.Author)
			// - ReferenceLetter (via testimonialResolver.ReferenceLetter)
			// - ValidatedSkills (via testimonialResolver.ValidatedSkills)
		}
	}

	return result, nil
}

// ValidationCount is the resolver for the validationCount field.
func (r *profileExperienceResolver) ValidationCount(ctx context.Context, obj *model.ProfileExperience) (int, error) {
	expID, err := uuid.Parse(obj.ID)
	if err != nil {
		return 0, fmt.Errorf("invalid experience ID: %w", err)
	}

	count, err := r.expValidationRepo.CountByProfileExperienceID(ctx, expID)
	if err != nil {
		return 0, fmt.Errorf("failed to count experience validations: %w", err)
	}

	return count, nil
}

// ValidationCount is the resolver for the validationCount field.
func (r *profileSkillResolver) ValidationCount(ctx context.Context, obj *model.ProfileSkill) (int, error) {
	skillID, err := uuid.Parse(obj.ID)
	if err != nil {
		return 0, fmt.Errorf("invalid skill ID: %w", err)
	}

	count, err := r.skillValidationRepo.CountByProfileSkillID(ctx, skillID)
	if err != nil {
		return 0, fmt.Errorf("failed to count skill validations: %w", err)
	}

	return count, nil
}

// SourceReferenceLetter is the resolver for the sourceReferenceLetter field.
func (r *profileSkillResolver) SourceReferenceLetter(ctx context.Context, obj *model.ProfileSkill) (*model.ReferenceLetter, error) {
	skillID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid skill ID: %w", err)
	}

	// Get the profile skill to find the source reference letter ID
	skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile skill: %w", err)
	}
	if skill == nil || skill.SourceReferenceLetterID == nil {
		return nil, nil
	}

	// Fetch the reference letter
	refLetter, err := r.refLetterRepo.GetByID(ctx, *skill.SourceReferenceLetterID)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}
	if refLetter == nil {
		return nil, nil
	}

	// Get user for the reference letter
	var gqlUser *model.User
	if refLetter.UserID != uuid.Nil {
		user, err := r.userRepo.GetByID(ctx, refLetter.UserID)
		if err == nil && user != nil {
			gqlUser = toGraphQLUser(user)
		}
	}

	// Get file for the reference letter
	var gqlFile *model.File
	if refLetter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *refLetter.FileID)
		if err == nil && file != nil {
			gqlFile = toGraphQLFile(file, gqlUser)
		}
	}

	return toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	fid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID: %w", err)
	}

	file, err := r.fileRepo.GetByID(ctx, fid)
	if err != nil {
		return nil, fmt.Errorf("failed to get file: %w", err)
	}

	if file == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, file.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for file: %w", err)
	}

	return toGraphQLFile(file, toGraphQLUser(user)), nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, userID string) ([]*model.File, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	files, err := r.fileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get files: %w", err)
	}

	// Fetch the user once for all files
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for files: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	result := make([]*model.File, len(files))
	for i, f := range files {
		result[i] = toGraphQLFile(f, gqlUser)
	}

	return result, nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *queryResolver) ReferenceLetter(ctx context.Context, id string) (*model.ReferenceLetter, error) {
	lid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid reference letter ID: %w", err)
	}

	letter, err := r.refLetterRepo.GetByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}

	if letter == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, letter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letter: %w", err)
	}

	// Fetch the file relation if present
	var gqlFile *model.File
	if letter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *letter.FileID)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		gqlFile = toGraphQLFile(file, toGraphQLUser(user))
	}

	return toGraphQLReferenceLetter(letter, toGraphQLUser(user), gqlFile), nil
}

// ReferenceLetters is the resolver for the referenceLetters field.
func (r *queryResolver) ReferenceLetters(ctx context.Context, userID string) ([]*model.ReferenceLetter, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	letters, err := r.refLetterRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letters: %w", err)
	}

	// Fetch the user once for all letters
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letters: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, l := range letters {
		if l.FileID != nil {
			fileIDs[*l.FileID] = true
		}
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.ReferenceLetter, len(letters))
	for i, l := range letters {
		var gqlFile *model.File
		if l.FileID != nil {
			gqlFile = fileMap[*l.FileID]
		}
		result[i] = toGraphQLReferenceLetter(l, gqlUser, gqlFile)
	}

	return result, nil
}

// Resume is the resolver for the resume field.
func (r *queryResolver) Resume(ctx context.Context, id string) (*model.Resume, error) {
	rid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid resume ID: %w", err)
	}

	resume, err := r.resumeRepo.GetByID(ctx, rid)
	if err != nil {
		return nil, fmt.Errorf("failed to get resume: %w", err)
	}

	if resume == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, resume.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for resume: %w", err)
	}

	// Fetch the file relation
	file, err := r.fileRepo.GetByID(ctx, resume.FileID)
	if err != nil {
		return nil, fmt.Errorf("failed to get file for resume: %w", err)
	}

	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(file, gqlUser)

	return toGraphQLResume(resume, gqlUser, gqlFile), nil
}

// Resumes is the resolver for the resumes field.
func (r *queryResolver) Resumes(ctx context.Context, userID string) ([]*model.Resume, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	resumes, err := r.resumeRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get resumes: %w", err)
	}

	// Fetch the user once for all resumes
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for resumes: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, res := range resumes {
		fileIDs[res.FileID] = true
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for resume: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.Resume, len(resumes))
	for i, res := range resumes {
		gqlFile := fileMap[res.FileID]
		result[i] = toGraphQLResume(res, gqlUser, gqlFile)
	}

	return result, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context, id string) (*model.Profile, error) {
	pid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid profile ID: %w", err)
	}

	profile, err := r.profileRepo.GetByID(ctx, pid)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile: %w", err)
	}
	if profile == nil {
		return nil, nil
	}

	return r.loadProfileData(ctx, profile)
}

// ProfileByUserID is the resolver for the profileByUserId field.
func (r *queryResolver) ProfileByUserID(ctx context.Context, userID string) (*model.Profile, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	profile, err := r.profileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile: %w", err)
	}
	if profile == nil {
		return nil, nil
	}

	return r.loadProfileData(ctx, profile)
}

// ProfileExperience is the resolver for the profileExperience field.
func (r *queryResolver) ProfileExperience(ctx context.Context, id string) (*model.ProfileExperience, error) {
	expID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid experience ID: %w", err)
	}

	experience, err := r.profileExpRepo.GetByID(ctx, expID)
	if err != nil {
		return nil, fmt.Errorf("failed to get experience: %w", err)
	}
	if experience == nil {
		return nil, nil
	}

	return toGraphQLProfileExperience(experience), nil
}

// ProfileEducation is the resolver for the profileEducation field.
func (r *queryResolver) ProfileEducation(ctx context.Context, id string) (*model.ProfileEducation, error) {
	eduID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid education ID: %w", err)
	}

	education, err := r.profileEduRepo.GetByID(ctx, eduID)
	if err != nil {
		return nil, fmt.Errorf("failed to get education: %w", err)
	}
	if education == nil {
		return nil, nil
	}

	return toGraphQLProfileEducation(education), nil
}

// ProfileSkill is the resolver for the profileSkill field.
func (r *queryResolver) ProfileSkill(ctx context.Context, id string) (*model.ProfileSkill, error) {
	skillID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid skill ID: %w", err)
	}

	skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
	if err != nil {
		return nil, fmt.Errorf("failed to get skill: %w", err)
	}
	if skill == nil {
		return nil, nil
	}

	return toGraphQLProfileSkill(skill), nil
}

// Testimonials is the resolver for the testimonials field.
func (r *queryResolver) Testimonials(ctx context.Context, profileID string) ([]*model.Testimonial, error) {
	pid, err := uuid.Parse(profileID)
	if err != nil {
		return nil, fmt.Errorf("invalid profile ID: %w", err)
	}

	testimonials, err := r.testimonialRepo.GetByProfileID(ctx, pid)
	if err != nil {
		return nil, fmt.Errorf("failed to get testimonials: %w", err)
	}

	// Collect unique reference letter IDs and author IDs
	refLetterIDs := make([]uuid.UUID, 0)
	authorIDs := make([]uuid.UUID, 0)
	authorIDSet := make(map[uuid.UUID]struct{})
	refLetterIDSet := make(map[uuid.UUID]struct{})

	for _, t := range testimonials {
		if _, exists := refLetterIDSet[t.ReferenceLetterID]; !exists {
			refLetterIDs = append(refLetterIDs, t.ReferenceLetterID)
			refLetterIDSet[t.ReferenceLetterID] = struct{}{}
		}
		if t.AuthorID != nil {
			if _, exists := authorIDSet[*t.AuthorID]; !exists {
				authorIDs = append(authorIDs, *t.AuthorID)
				authorIDSet[*t.AuthorID] = struct{}{}
			}
		}
	}

	// Batch load all authors in one query
	authorsMap, err := r.authorRepo.GetByIDs(ctx, authorIDs)
	if err != nil {
		return nil, fmt.Errorf("failed to batch load authors: %w", err)
	}

	// Attach authors to testimonials
	for _, t := range testimonials {
		if t.AuthorID != nil {
			if author, ok := authorsMap[*t.AuthorID]; ok {
				t.Author = author
			}
		}
	}

	// Build map of reference letter ID -> validated skills
	validatedSkillsByRefLetter := make(map[string][]*model.ProfileSkill)

	// Collect all skill IDs from all reference letters first
	allSkillIDs := make([]uuid.UUID, 0)
	skillIDSet := make(map[uuid.UUID]struct{})
	skillValidationsByLetter := make(map[uuid.UUID][]*domain.SkillValidation)

	for _, refLetterID := range refLetterIDs {
		// Get skill validations for this reference letter
		skillValidations, err := r.skillValidationRepo.GetByReferenceLetterID(ctx, refLetterID)
		if err != nil {
			return nil, fmt.Errorf("failed to get skill validations for letter %s: %w", refLetterID, err)
		}
		skillValidationsByLetter[refLetterID] = skillValidations

		// Collect skill IDs
		for _, sv := range skillValidations {
			if _, exists := skillIDSet[sv.ProfileSkillID]; !exists {
				allSkillIDs = append(allSkillIDs, sv.ProfileSkillID)
				skillIDSet[sv.ProfileSkillID] = struct{}{}
			}
		}
	}

	// Batch load all profile skills in one query
	skillsMap, err := r.profileSkillRepo.GetByIDs(ctx, allSkillIDs)
	if err != nil {
		return nil, fmt.Errorf("failed to batch load profile skills: %w", err)
	}

	// Build the validated skills map using the loaded skills
	for refLetterID, skillValidations := range skillValidationsByLetter {
		var skills []*model.ProfileSkill
		for _, sv := range skillValidations {
			if profileSkill, ok := skillsMap[sv.ProfileSkillID]; ok {
				skills = append(skills, toGraphQLProfileSkill(profileSkill))
			}
		}
		validatedSkillsByRefLetter[refLetterID.String()] = skills
	}

	return toGraphQLTestimonials(testimonials, validatedSkillsByRefLetter), nil
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string) (*model.Author, error) {
	authorID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid author ID: %w", err)
	}

	author, err := r.authorRepo.GetByID(ctx, authorID)
	if err != nil {
		return nil, fmt.Errorf("failed to get author: %w", err)
	}
	if author == nil {
		return nil, nil
	}

	// Get image URL if author has an image
	var imageURL *string
	if author.ImageID != nil {
		file, err := r.fileRepo.GetByID(ctx, *author.ImageID)
		if err == nil && file != nil {
			url, err := r.storage.GetPresignedURL(ctx, file.StorageKey, time.Hour)
			if err == nil {
				imageURL = &url
			}
		}
	}

	return toGraphQLAuthorWithImage(author, imageURL), nil
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context, profileID string) ([]*model.Author, error) {
	pid, err := uuid.Parse(profileID)
	if err != nil {
		return nil, fmt.Errorf("invalid profile ID: %w", err)
	}

	authors, err := r.authorRepo.GetByProfileID(ctx, pid)
	if err != nil {
		return nil, fmt.Errorf("failed to get authors: %w", err)
	}

	// Collect image IDs for batch fetching
	var imageIDs []uuid.UUID
	for _, a := range authors {
		if a.ImageID != nil {
			imageIDs = append(imageIDs, *a.ImageID)
		}
	}

	// Fetch image files and generate URLs
	imageURLs := make(map[uuid.UUID]string)
	if len(imageIDs) > 0 {
		for _, imageID := range imageIDs {
			file, err := r.fileRepo.GetByID(ctx, imageID)
			if err == nil && file != nil {
				url, err := r.storage.GetPresignedURL(ctx, file.StorageKey, time.Hour)
				if err == nil {
					imageURLs[imageID] = url
				}
			}
		}
	}

	result := make([]*model.Author, len(authors))
	for i, a := range authors {
		var imageURL *string
		if a.ImageID != nil {
			if url, ok := imageURLs[*a.ImageID]; ok {
				imageURL = &url
			}
		}
		result[i] = toGraphQLAuthorWithImage(a, imageURL)
	}
	return result, nil
}

// SkillValidations is the resolver for the skillValidations field.
func (r *queryResolver) SkillValidations(ctx context.Context, skillID string) ([]*model.SkillValidation, error) {
	sid, err := uuid.Parse(skillID)
	if err != nil {
		return nil, fmt.Errorf("invalid skill ID: %w", err)
	}

	validations, err := r.skillValidationRepo.GetByProfileSkillID(ctx, sid)
	if err != nil {
		return nil, fmt.Errorf("failed to get skill validations: %w", err)
	}

	result := make([]*model.SkillValidation, len(validations))
	for i, v := range validations {
		result[i] = &model.SkillValidation{
			ID:           v.ID.String(),
			QuoteSnippet: v.QuoteSnippet,
			CreatedAt:    v.CreatedAt,
		}
	}

	return result, nil
}

// ExperienceValidations is the resolver for the experienceValidations field.
func (r *queryResolver) ExperienceValidations(ctx context.Context, experienceID string) ([]*model.ExperienceValidation, error) {
	eid, err := uuid.Parse(experienceID)
	if err != nil {
		return nil, fmt.Errorf("invalid experience ID: %w", err)
	}

	validations, err := r.expValidationRepo.GetByProfileExperienceID(ctx, eid)
	if err != nil {
		return nil, fmt.Errorf("failed to get experience validations: %w", err)
	}

	result := make([]*model.ExperienceValidation, len(validations))
	for i, v := range validations {
		result[i] = &model.ExperienceValidation{
			ID:           v.ID.String(),
			QuoteSnippet: v.QuoteSnippet,
			CreatedAt:    v.CreatedAt,
		}
	}

	return result, nil
}

// CheckDuplicateFile is the resolver for the checkDuplicateFile field.
func (r *queryResolver) CheckDuplicateFile(ctx context.Context, userID string, contentHash string) (*model.DuplicateFileDetected, error) {
	r.log.Info("Checking for duplicate file",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("content_hash", contentHash),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return nil, fmt.Errorf("invalid user ID format")
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	// Check for existing file with same hash
	existingFile, err := r.fileRepo.GetByUserIDAndContentHash(ctx, uid, contentHash)
	if err != nil {
		r.log.Error("Failed to check for duplicate file",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_hash", contentHash),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to check for duplicate file: %w", err)
	}

	if existingFile == nil {
		// No duplicate found
		return nil, nil
	}

	r.log.Info("Duplicate file found",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("content_hash", contentHash),
		logger.String("existing_file_id", existingFile.ID.String()),
	)

	// Find associated resume
	resumes, err := r.resumeRepo.GetByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get resumes",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get resumes: %w", err)
	}

	var existingResume *domain.Resume
	for _, res := range resumes {
		if res.FileID == existingFile.ID {
			existingResume = res
			break
		}
	}

	// Find associated reference letter
	refLetters, err := r.refLetterRepo.GetByUserID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to get reference letters",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to get reference letters: %w", err)
	}

	var existingRefLetter *domain.ReferenceLetter
	for _, rl := range refLetters {
		if rl.FileID != nil && *rl.FileID == existingFile.ID {
			existingRefLetter = rl
			break
		}
	}

	gqlUser := toGraphQLUser(user)
	gqlExistingFile := toGraphQLFile(existingFile, gqlUser)

	var gqlExistingResume *model.Resume
	if existingResume != nil {
		gqlExistingResume = toGraphQLResume(existingResume, gqlUser, gqlExistingFile)
	}

	var gqlExistingRefLetter *model.ReferenceLetter
	if existingRefLetter != nil {
		gqlExistingRefLetter = toGraphQLReferenceLetter(existingRefLetter, gqlUser, gqlExistingFile)
	}

	return &model.DuplicateFileDetected{
		ExistingFile:            gqlExistingFile,
		ExistingResume:          gqlExistingResume,
		ExistingReferenceLetter: gqlExistingRefLetter,
		Message:                 fmt.Sprintf("This document was already uploaded on %s.", existingFile.CreatedAt.Format("Jan 2, 2006")),
	}, nil
}

// DocumentProcessingStatus is the resolver for the documentProcessingStatus field.
func (r *queryResolver) DocumentProcessingStatus(ctx context.Context, resumeID *string, referenceLetterID *string) (*model.DocumentProcessingStatus, error) {
	if resumeID == nil && referenceLetterID == nil {
		return nil, fmt.Errorf("at least one of resumeId or referenceLetterID must be provided")
	}

	result := &model.DocumentProcessingStatus{
		AllComplete: true,
	}

	// Check resume status
	if resumeID != nil {
		rid, err := uuid.Parse(*resumeID)
		if err != nil {
			return nil, fmt.Errorf("invalid resume ID: %w", err)
		}
		resume, err := r.resumeRepo.GetByID(ctx, rid)
		if err != nil {
			return nil, fmt.Errorf("failed to get resume: %w", err)
		}
		if resume != nil {
			user, _ := r.userRepo.GetByID(ctx, resume.UserID)
			gqlUser := toGraphQLUser(user)
			file, _ := r.fileRepo.GetByID(ctx, resume.FileID)
			gqlFile := toGraphQLFile(file, gqlUser)
			result.Resume = toGraphQLResume(resume, gqlUser, gqlFile)

			if resume.Status != domain.ResumeStatusCompleted && resume.Status != domain.ResumeStatusFailed {
				result.AllComplete = false
			}
		}
	}

	// Check reference letter status
	if referenceLetterID != nil {
		lid, err := uuid.Parse(*referenceLetterID)
		if err != nil {
			return nil, fmt.Errorf("invalid reference letter ID: %w", err)
		}
		refLetter, err := r.refLetterRepo.GetByID(ctx, lid)
		if err != nil {
			return nil, fmt.Errorf("failed to get reference letter: %w", err)
		}
		if refLetter != nil {
			user, _ := r.userRepo.GetByID(ctx, refLetter.UserID)
			gqlUser := toGraphQLUser(user)
			var gqlFile *model.File
			if refLetter.FileID != nil {
				file, _ := r.fileRepo.GetByID(ctx, *refLetter.FileID)
				gqlFile = toGraphQLFile(file, gqlUser)
			}
			result.ReferenceLetter = toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile)

			if refLetter.Status != domain.ReferenceLetterStatusCompleted && refLetter.Status != domain.ReferenceLetterStatusFailed {
				result.AllComplete = false
			}
		}
	}

	return result, nil
}

// DocumentDetectionStatus is the resolver for the documentDetectionStatus field.
func (r *queryResolver) DocumentDetectionStatus(ctx context.Context, fileID string) (*model.DocumentDetectionStatus, error) {
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID: %w", err)
	}

	file, err := r.fileRepo.GetByID(ctx, fid)
	if err != nil {
		return nil, fmt.Errorf("failed to get file: %w", err)
	}
	if file == nil {
		return nil, fmt.Errorf("file not found")
	}

	// Map domain detection status to GraphQL enum
	status := model.DetectionStatusPending
	if file.DetectionStatus != nil {
		switch *file.DetectionStatus {
		case domain.DetectionStatusProcessing:
			status = model.DetectionStatusProcessing
		case domain.DetectionStatusCompleted:
			status = model.DetectionStatusCompleted
		case domain.DetectionStatusFailed:
			status = model.DetectionStatusFailed
		default:
			status = model.DetectionStatusPending
		}
	}

	result := &model.DocumentDetectionStatus{
		FileID: fileID,
		Status: status,
		Error:  file.DetectionError,
	}

	// Deserialize detection result if completed
	if status == model.DetectionStatusCompleted && len(file.DetectionResult) > 0 {
		var detection domain.DocumentDetectionResult
		if err := json.Unmarshal(file.DetectionResult, &detection); err != nil {
			return nil, fmt.Errorf("failed to deserialize detection result: %w", err)
		}

		var gqlTypeHint model.DocumentTypeHint
		switch detection.DocumentTypeHint {
		case domain.DocumentTypeResume:
			gqlTypeHint = model.DocumentTypeHintResume
		case domain.DocumentTypeReferenceLetter:
			gqlTypeHint = model.DocumentTypeHintReferenceLetter
		case domain.DocumentTypeHybrid:
			gqlTypeHint = model.DocumentTypeHintHybrid
		default:
			gqlTypeHint = model.DocumentTypeHintUnknown
		}

		result.Detection = &model.DocumentDetectionResult{
			HasCareerInfo:     detection.HasCareerInfo,
			HasTestimonial:    detection.HasTestimonial,
			TestimonialAuthor: detection.TestimonialAuthor,
			Confidence:        detection.Confidence,
			Summary:           detection.Summary,
			DocumentTypeHint:  gqlTypeHint,
			FileID:            fileID,
		}
	}

	return result, nil
}

// Skill is the resolver for the skill field.
func (r *skillValidationResolver) Skill(ctx context.Context, obj *model.SkillValidation) (*model.ProfileSkill, error) {
	// The skill validation was loaded from the database, we need to look up the skill
	// We need to get the ProfileSkillID from the domain validation
	// Since we don't have it in the model, we need to fetch the validation again
	validationID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid validation ID: %w", err)
	}

	validation, err := r.skillValidationRepo.GetByID(ctx, validationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get skill validation: %w", err)
	}
	if validation == nil {
		return nil, nil
	}

	skill, err := r.profileSkillRepo.GetByID(ctx, validation.ProfileSkillID)
	if err != nil {
		return nil, fmt.Errorf("failed to get profile skill: %w", err)
	}
	if skill == nil {
		return nil, nil
	}

	return toGraphQLProfileSkill(skill), nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *skillValidationResolver) ReferenceLetter(ctx context.Context, obj *model.SkillValidation) (*model.ReferenceLetter, error) {
	validationID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid validation ID: %w", err)
	}

	validation, err := r.skillValidationRepo.GetByID(ctx, validationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get skill validation: %w", err)
	}
	if validation == nil {
		return nil, nil
	}

	refLetter, err := r.refLetterRepo.GetByID(ctx, validation.ReferenceLetterID)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}
	if refLetter == nil {
		return nil, nil
	}

	// Get the user for the reference letter
	user, err := r.userRepo.GetByID(ctx, refLetter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Get the file if present
	var gqlFile *model.File
	if refLetter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *refLetter.FileID)
		if err == nil && file != nil {
			gqlFile = toGraphQLFile(file, gqlUser)
		}
	}

	return toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile), nil
}

// Testimonial is the resolver for the testimonial field.
func (r *skillValidationResolver) Testimonial(ctx context.Context, obj *model.SkillValidation) (*model.Testimonial, error) {
	validationID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid validation ID: %w", err)
	}

	// Get the skill validation to find the testimonial ID
	validation, err := r.skillValidationRepo.GetByID(ctx, validationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get skill validation: %w", err)
	}
	if validation == nil || validation.TestimonialID == nil {
		return nil, nil
	}

	// Fetch the testimonial
	testimonial, err := r.testimonialRepo.GetByID(ctx, *validation.TestimonialID)
	if err != nil {
		return nil, fmt.Errorf("failed to get testimonial: %w", err)
	}
	if testimonial == nil {
		return nil, nil
	}

	return toGraphQLTestimonial(testimonial, nil, nil), nil
}

// Author is the resolver for the author field.
func (r *testimonialResolver) Author(ctx context.Context, obj *model.Testimonial) (*model.Author, error) {
	testimonialID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid testimonial ID: %w", err)
	}

	// Get the testimonial to find the author ID
	testimonial, err := r.testimonialRepo.GetByID(ctx, testimonialID)
	if err != nil {
		return nil, fmt.Errorf("failed to get testimonial: %w", err)
	}
	if testimonial == nil || testimonial.AuthorID == nil {
		return nil, nil
	}

	author, err := r.authorRepo.GetByID(ctx, *testimonial.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("failed to get author: %w", err)
	}
	if author == nil {
		return nil, nil
	}

	// Get image URL if author has an image
	var imageURL *string
	if author.ImageID != nil {
		file, err := r.fileRepo.GetByID(ctx, *author.ImageID)
		if err == nil && file != nil {
			url, err := r.storage.GetPresignedURL(ctx, file.StorageKey, time.Hour)
			if err == nil {
				imageURL = &url
			}
		}
	}

	return toGraphQLAuthorWithImage(author, imageURL), nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *testimonialResolver) ReferenceLetter(ctx context.Context, obj *model.Testimonial) (*model.ReferenceLetter, error) {
	testimonialID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid testimonial ID: %w", err)
	}

	// Get the testimonial to find the reference letter ID
	testimonial, err := r.testimonialRepo.GetByID(ctx, testimonialID)
	if err != nil {
		return nil, fmt.Errorf("failed to get testimonial: %w", err)
	}
	if testimonial == nil {
		return nil, nil
	}

	// Get the reference letter
	refLetter, err := r.refLetterRepo.GetByID(ctx, testimonial.ReferenceLetterID)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}
	if refLetter == nil {
		return nil, nil
	}

	// Get the user for the reference letter
	user, err := r.userRepo.GetByID(ctx, refLetter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Get the file if present
	var gqlFile *model.File
	if refLetter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *refLetter.FileID)
		if err != nil {
			r.log.Error("Failed to get file for reference letter",
				logger.Feature("testimonial"),
				logger.String("reference_letter_id", refLetter.ID.String()),
				logger.Err(err),
			)
			// Don't fail the request, just skip the file
		} else if file != nil {
			gqlFile = toGraphQLFile(file, gqlUser)
		}
	}

	return toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile), nil
}

// ValidatedSkills is the resolver for the validatedSkills field.
func (r *testimonialResolver) ValidatedSkills(ctx context.Context, obj *model.Testimonial) ([]*model.ProfileSkill, error) {
	testimonialID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid testimonial ID: %w", err)
	}

	// Get skill validations for this specific testimonial
	validations, err := r.skillValidationRepo.GetByTestimonialID(ctx, testimonialID)
	if err != nil {
		return nil, fmt.Errorf("failed to get skill validations: %w", err)
	}

	// Collect unique skill IDs
	skillIDs := make(map[uuid.UUID]bool)
	for _, v := range validations {
		skillIDs[v.ProfileSkillID] = true
	}

	// Fetch the skills
	var skills []*model.ProfileSkill
	for skillID := range skillIDs {
		skill, err := r.profileSkillRepo.GetByID(ctx, skillID)
		if err != nil {
			r.log.Error("Failed to get skill for validation",
				logger.Feature("testimonial"),
				logger.String("skill_id", skillID.String()),
				logger.Err(err),
			)
			continue
		}
		if skill != nil {
			skills = append(skills, toGraphQLProfileSkill(skill))
		}
	}

	return skills, nil
}

// ExperienceValidation returns generated.ExperienceValidationResolver implementation.
func (r *Resolver) ExperienceValidation() generated.ExperienceValidationResolver {
	return &experienceValidationResolver{r}
}

// File returns generated.FileResolver implementation.
func (r *Resolver) File() generated.FileResolver { return &fileResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Profile returns generated.ProfileResolver implementation.
func (r *Resolver) Profile() generated.ProfileResolver { return &profileResolver{r} }

// ProfileExperience returns generated.ProfileExperienceResolver implementation.
func (r *Resolver) ProfileExperience() generated.ProfileExperienceResolver {
	return &profileExperienceResolver{r}
}

// ProfileSkill returns generated.ProfileSkillResolver implementation.
func (r *Resolver) ProfileSkill() generated.ProfileSkillResolver { return &profileSkillResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// SkillValidation returns generated.SkillValidationResolver implementation.
func (r *Resolver) SkillValidation() generated.SkillValidationResolver {
	return &skillValidationResolver{r}
}

// Testimonial returns generated.TestimonialResolver implementation.
func (r *Resolver) Testimonial() generated.TestimonialResolver { return &testimonialResolver{r} }

type experienceValidationResolver struct{ *Resolver }
type fileResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type profileResolver struct{ *Resolver }
type profileExperienceResolver struct{ *Resolver }
type profileSkillResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type skillValidationResolver struct{ *Resolver }
type testimonialResolver struct{ *Resolver }
