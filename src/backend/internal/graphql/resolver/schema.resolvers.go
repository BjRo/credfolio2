package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/internal/domain"
	"backend/internal/graphql/generated"
	"backend/internal/graphql/model"
	"backend/internal/logger"
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
)

// Relationship is the resolver for the relationship field.
func (r *extractedAuthorResolver) Relationship(ctx context.Context, obj *model.ExtractedAuthor) (domain.AuthorRelationship, error) {
	panic(fmt.Errorf("not implemented: Relationship - relationship"))
}

// Strength is the resolver for the strength field.
func (r *extractedRecommendationResolver) Strength(ctx context.Context, obj *model.ExtractedRecommendation) (domain.RecommendationStrength, error) {
	panic(fmt.Errorf("not implemented: Strength - strength"))
}

// Category is the resolver for the category field.
func (r *extractedSkillResolver) Category(ctx context.Context, obj *model.ExtractedSkill) (domain.SkillCategory, error) {
	panic(fmt.Errorf("not implemented: Category - category"))
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, userID string, file graphql.Upload) (model.UploadFileResponse, error) {
	r.log.Info("File upload started",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("filename", file.Filename),
		logger.String("content_type", file.ContentType),
		logger.Int64("size_bytes", file.Size),
	)

	// Parse and validate user ID
	uid, err := uuid.Parse(userID)
	if err != nil {
		r.log.Warning("Invalid user ID format",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "invalid user ID format",
			Field:   "userId",
		}, nil
	}

	// Verify user exists
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		r.log.Error("Failed to verify user",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to verify user: %w", err)
	}
	if user == nil {
		r.log.Warning("User not found",
			logger.Feature("upload"),
			logger.String("user_id", userID),
		)
		return &model.FileValidationError{
			Message: "user not found",
			Field:   "userId",
		}, nil
	}

	// Validate file type
	allowedTypes := map[string]bool{
		"application/pdf": true,
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
		"text/plain": true,
	}

	if !allowedTypes[file.ContentType] {
		r.log.Warning("File type not allowed",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("content_type", file.ContentType),
		)
		return &model.FileValidationError{
			Message: "file type not allowed: must be PDF, DOCX, or TXT",
			Field:   "contentType",
		}, nil
	}

	// Validate file size (max 10MB)
	const maxSize = 10 * 1024 * 1024
	if file.Size > maxSize {
		r.log.Warning("File too large",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.Int64("size_bytes", file.Size),
			logger.Int("max_bytes", maxSize),
		)
		return &model.FileValidationError{
			Message: "file too large: maximum size is 10MB",
			Field:   "size",
		}, nil
	}

	// Generate storage key
	fileID := uuid.New()
	storageKey := fmt.Sprintf("uploads/%s/%s/%s", uid.String(), fileID.String(), file.Filename)

	// Upload to storage
	_, err = r.storage.Upload(ctx, storageKey, file.File, file.Size, file.ContentType)
	if err != nil {
		r.log.Error("Failed to upload file to storage",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("storage_key", storageKey),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to upload file to storage: %w", err)
	}

	// Create file record
	domainFile := &domain.File{
		ID:          fileID,
		UserID:      uid,
		Filename:    file.Filename,
		ContentType: file.ContentType,
		SizeBytes:   file.Size,
		StorageKey:  storageKey,
	}

	if err := r.fileRepo.Create(ctx, domainFile); err != nil {
		r.log.Error("Failed to create file record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		// Attempt to clean up uploaded file
		_ = r.storage.Delete(ctx, storageKey) //nolint:errcheck // Best effort cleanup
		return nil, fmt.Errorf("failed to create file record: %w", err)
	}

	// Create reference letter record with pending status
	refLetter := &domain.ReferenceLetter{
		ID:     uuid.New(),
		UserID: uid,
		FileID: &fileID,
		Status: domain.ReferenceLetterStatusPending,
	}

	if err := r.refLetterRepo.Create(ctx, refLetter); err != nil {
		r.log.Error("Failed to create reference letter record",
			logger.Feature("upload"),
			logger.String("user_id", userID),
			logger.String("file_id", fileID.String()),
			logger.Err(err),
		)
		return nil, fmt.Errorf("failed to create reference letter record: %w", err)
	}

	// Enqueue document processing job
	if r.jobEnqueuer != nil {
		if enqueueErr := r.jobEnqueuer.EnqueueDocumentProcessing(ctx, domain.DocumentProcessingRequest{
			ReferenceLetterID: refLetter.ID,
			FileID:            fileID,
			StorageKey:        storageKey,
		}); enqueueErr != nil {
			r.log.Error("Failed to enqueue document processing",
				logger.Feature("upload"),
				logger.String("user_id", userID),
				logger.String("file_id", fileID.String()),
				logger.String("reference_letter_id", refLetter.ID.String()),
				logger.Err(enqueueErr),
			)
			return nil, fmt.Errorf("failed to enqueue document processing: %w", enqueueErr)
		}
	}

	r.log.Info("File upload completed",
		logger.Feature("upload"),
		logger.String("user_id", userID),
		logger.String("file_id", fileID.String()),
		logger.String("reference_letter_id", refLetter.ID.String()),
		logger.String("storage_key", storageKey),
	)

	// Build response
	gqlUser := toGraphQLUser(user)
	gqlFile := toGraphQLFile(domainFile, gqlUser)
	gqlRefLetter := toGraphQLReferenceLetter(refLetter, gqlUser, gqlFile)

	return &model.UploadFileResult{
		File:            gqlFile,
		ReferenceLetter: gqlRefLetter,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return toGraphQLUser(user), nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	fid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID: %w", err)
	}

	file, err := r.fileRepo.GetByID(ctx, fid)
	if err != nil {
		return nil, fmt.Errorf("failed to get file: %w", err)
	}

	if file == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, file.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for file: %w", err)
	}

	return toGraphQLFile(file, toGraphQLUser(user)), nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, userID string) ([]*model.File, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	files, err := r.fileRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get files: %w", err)
	}

	// Fetch the user once for all files
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for files: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	result := make([]*model.File, len(files))
	for i, f := range files {
		result[i] = toGraphQLFile(f, gqlUser)
	}

	return result, nil
}

// ReferenceLetter is the resolver for the referenceLetter field.
func (r *queryResolver) ReferenceLetter(ctx context.Context, id string) (*model.ReferenceLetter, error) {
	lid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid reference letter ID: %w", err)
	}

	letter, err := r.refLetterRepo.GetByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letter: %w", err)
	}

	if letter == nil {
		return nil, nil
	}

	// Fetch the user relation
	user, err := r.userRepo.GetByID(ctx, letter.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letter: %w", err)
	}

	// Fetch the file relation if present
	var gqlFile *model.File
	if letter.FileID != nil {
		file, err := r.fileRepo.GetByID(ctx, *letter.FileID)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		gqlFile = toGraphQLFile(file, toGraphQLUser(user))
	}

	return toGraphQLReferenceLetter(letter, toGraphQLUser(user), gqlFile), nil
}

// ReferenceLetters is the resolver for the referenceLetters field.
func (r *queryResolver) ReferenceLetters(ctx context.Context, userID string) ([]*model.ReferenceLetter, error) {
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	letters, err := r.refLetterRepo.GetByUserID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get reference letters: %w", err)
	}

	// Fetch the user once for all letters
	user, err := r.userRepo.GetByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user for reference letters: %w", err)
	}
	gqlUser := toGraphQLUser(user)

	// Collect all unique file IDs to batch fetch files
	fileIDs := make(map[uuid.UUID]bool)
	for _, l := range letters {
		if l.FileID != nil {
			fileIDs[*l.FileID] = true
		}
	}

	// Fetch all files and create a lookup map
	fileMap := make(map[uuid.UUID]*model.File)
	for fid := range fileIDs {
		file, err := r.fileRepo.GetByID(ctx, fid)
		if err != nil {
			return nil, fmt.Errorf("failed to get file for reference letter: %w", err)
		}
		if file != nil {
			fileMap[fid] = toGraphQLFile(file, gqlUser)
		}
	}

	result := make([]*model.ReferenceLetter, len(letters))
	for i, l := range letters {
		var gqlFile *model.File
		if l.FileID != nil {
			gqlFile = fileMap[*l.FileID]
		}
		result[i] = toGraphQLReferenceLetter(l, gqlUser, gqlFile)
	}

	return result, nil
}

// ExtractedAuthor returns generated.ExtractedAuthorResolver implementation.
func (r *Resolver) ExtractedAuthor() generated.ExtractedAuthorResolver {
	return &extractedAuthorResolver{r}
}

// ExtractedRecommendation returns generated.ExtractedRecommendationResolver implementation.
func (r *Resolver) ExtractedRecommendation() generated.ExtractedRecommendationResolver {
	return &extractedRecommendationResolver{r}
}

// ExtractedSkill returns generated.ExtractedSkillResolver implementation.
func (r *Resolver) ExtractedSkill() generated.ExtractedSkillResolver {
	return &extractedSkillResolver{r}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type extractedAuthorResolver struct{ *Resolver }
type extractedRecommendationResolver struct{ *Resolver }
type extractedSkillResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
