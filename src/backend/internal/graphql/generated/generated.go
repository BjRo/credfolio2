// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"backend/internal/domain"
	"backend/internal/graphql/model"
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ExtractedAuthor() ExtractedAuthorResolver
	ExtractedRecommendation() ExtractedRecommendationResolver
	ExtractedSkill() ExtractedSkillResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ExtractedAccomplishment struct {
		Confidence  func(childComplexity int) int
		Description func(childComplexity int) int
		Impact      func(childComplexity int) int
		Timeframe   func(childComplexity int) int
	}

	ExtractedAuthor struct {
		Confidence          func(childComplexity int) int
		Name                func(childComplexity int) int
		Organization        func(childComplexity int) int
		Relationship        func(childComplexity int) int
		RelationshipDetails func(childComplexity int) int
		Title               func(childComplexity int) int
	}

	ExtractedLetterData struct {
		Accomplishments func(childComplexity int) int
		Author          func(childComplexity int) int
		Metadata        func(childComplexity int) int
		Qualities       func(childComplexity int) int
		Recommendation  func(childComplexity int) int
		Skills          func(childComplexity int) int
	}

	ExtractedQuality struct {
		Confidence func(childComplexity int) int
		Evidence   func(childComplexity int) int
		Trait      func(childComplexity int) int
	}

	ExtractedRecommendation struct {
		Confidence func(childComplexity int) int
		KeyQuotes  func(childComplexity int) int
		Sentiment  func(childComplexity int) int
		Strength   func(childComplexity int) int
		Summary    func(childComplexity int) int
	}

	ExtractedSkill struct {
		Category       func(childComplexity int) int
		Confidence     func(childComplexity int) int
		Context        func(childComplexity int) int
		Mentions       func(childComplexity int) int
		Name           func(childComplexity int) int
		NormalizedName func(childComplexity int) int
	}

	ExtractionMetadata struct {
		ExtractedAt       func(childComplexity int) int
		ModelVersion      func(childComplexity int) int
		OverallConfidence func(childComplexity int) int
		ProcessingTimeMs  func(childComplexity int) int
		Warnings          func(childComplexity int) int
		WarningsCount     func(childComplexity int) int
	}

	File struct {
		ContentType func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Filename    func(childComplexity int) int
		ID          func(childComplexity int) int
		SizeBytes   func(childComplexity int) int
		StorageKey  func(childComplexity int) int
		User        func(childComplexity int) int
	}

	FileValidationError struct {
		Field   func(childComplexity int) int
		Message func(childComplexity int) int
	}

	Mutation struct {
		UploadFile func(childComplexity int, userID string, file graphql.Upload) int
	}

	Query struct {
		File             func(childComplexity int, id string) int
		Files            func(childComplexity int, userID string) int
		ReferenceLetter  func(childComplexity int, id string) int
		ReferenceLetters func(childComplexity int, userID string) int
		User             func(childComplexity int, id string) int
	}

	ReferenceLetter struct {
		AuthorName    func(childComplexity int) int
		AuthorTitle   func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DateWritten   func(childComplexity int) int
		ExtractedData func(childComplexity int) int
		File          func(childComplexity int) int
		ID            func(childComplexity int) int
		Organization  func(childComplexity int) int
		RawText       func(childComplexity int) int
		Status        func(childComplexity int) int
		Title         func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		User          func(childComplexity int) int
	}

	UploadFileResult struct {
		File            func(childComplexity int) int
		ReferenceLetter func(childComplexity int) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}
}

type ExtractedAuthorResolver interface {
	Relationship(ctx context.Context, obj *model.ExtractedAuthor) (domain.AuthorRelationship, error)
}
type ExtractedRecommendationResolver interface {
	Strength(ctx context.Context, obj *model.ExtractedRecommendation) (domain.RecommendationStrength, error)
}
type ExtractedSkillResolver interface {
	Category(ctx context.Context, obj *model.ExtractedSkill) (domain.SkillCategory, error)
}
type MutationResolver interface {
	UploadFile(ctx context.Context, userID string, file graphql.Upload) (model.UploadFileResponse, error)
}
type QueryResolver interface {
	User(ctx context.Context, id string) (*model.User, error)
	File(ctx context.Context, id string) (*model.File, error)
	Files(ctx context.Context, userID string) ([]*model.File, error)
	ReferenceLetter(ctx context.Context, id string) (*model.ReferenceLetter, error)
	ReferenceLetters(ctx context.Context, userID string) ([]*model.ReferenceLetter, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ExtractedAccomplishment.confidence":
		if e.complexity.ExtractedAccomplishment.Confidence == nil {
			break
		}

		return e.complexity.ExtractedAccomplishment.Confidence(childComplexity), true
	case "ExtractedAccomplishment.description":
		if e.complexity.ExtractedAccomplishment.Description == nil {
			break
		}

		return e.complexity.ExtractedAccomplishment.Description(childComplexity), true
	case "ExtractedAccomplishment.impact":
		if e.complexity.ExtractedAccomplishment.Impact == nil {
			break
		}

		return e.complexity.ExtractedAccomplishment.Impact(childComplexity), true
	case "ExtractedAccomplishment.timeframe":
		if e.complexity.ExtractedAccomplishment.Timeframe == nil {
			break
		}

		return e.complexity.ExtractedAccomplishment.Timeframe(childComplexity), true

	case "ExtractedAuthor.confidence":
		if e.complexity.ExtractedAuthor.Confidence == nil {
			break
		}

		return e.complexity.ExtractedAuthor.Confidence(childComplexity), true
	case "ExtractedAuthor.name":
		if e.complexity.ExtractedAuthor.Name == nil {
			break
		}

		return e.complexity.ExtractedAuthor.Name(childComplexity), true
	case "ExtractedAuthor.organization":
		if e.complexity.ExtractedAuthor.Organization == nil {
			break
		}

		return e.complexity.ExtractedAuthor.Organization(childComplexity), true
	case "ExtractedAuthor.relationship":
		if e.complexity.ExtractedAuthor.Relationship == nil {
			break
		}

		return e.complexity.ExtractedAuthor.Relationship(childComplexity), true
	case "ExtractedAuthor.relationshipDetails":
		if e.complexity.ExtractedAuthor.RelationshipDetails == nil {
			break
		}

		return e.complexity.ExtractedAuthor.RelationshipDetails(childComplexity), true
	case "ExtractedAuthor.title":
		if e.complexity.ExtractedAuthor.Title == nil {
			break
		}

		return e.complexity.ExtractedAuthor.Title(childComplexity), true

	case "ExtractedLetterData.accomplishments":
		if e.complexity.ExtractedLetterData.Accomplishments == nil {
			break
		}

		return e.complexity.ExtractedLetterData.Accomplishments(childComplexity), true
	case "ExtractedLetterData.author":
		if e.complexity.ExtractedLetterData.Author == nil {
			break
		}

		return e.complexity.ExtractedLetterData.Author(childComplexity), true
	case "ExtractedLetterData.metadata":
		if e.complexity.ExtractedLetterData.Metadata == nil {
			break
		}

		return e.complexity.ExtractedLetterData.Metadata(childComplexity), true
	case "ExtractedLetterData.qualities":
		if e.complexity.ExtractedLetterData.Qualities == nil {
			break
		}

		return e.complexity.ExtractedLetterData.Qualities(childComplexity), true
	case "ExtractedLetterData.recommendation":
		if e.complexity.ExtractedLetterData.Recommendation == nil {
			break
		}

		return e.complexity.ExtractedLetterData.Recommendation(childComplexity), true
	case "ExtractedLetterData.skills":
		if e.complexity.ExtractedLetterData.Skills == nil {
			break
		}

		return e.complexity.ExtractedLetterData.Skills(childComplexity), true

	case "ExtractedQuality.confidence":
		if e.complexity.ExtractedQuality.Confidence == nil {
			break
		}

		return e.complexity.ExtractedQuality.Confidence(childComplexity), true
	case "ExtractedQuality.evidence":
		if e.complexity.ExtractedQuality.Evidence == nil {
			break
		}

		return e.complexity.ExtractedQuality.Evidence(childComplexity), true
	case "ExtractedQuality.trait":
		if e.complexity.ExtractedQuality.Trait == nil {
			break
		}

		return e.complexity.ExtractedQuality.Trait(childComplexity), true

	case "ExtractedRecommendation.confidence":
		if e.complexity.ExtractedRecommendation.Confidence == nil {
			break
		}

		return e.complexity.ExtractedRecommendation.Confidence(childComplexity), true
	case "ExtractedRecommendation.keyQuotes":
		if e.complexity.ExtractedRecommendation.KeyQuotes == nil {
			break
		}

		return e.complexity.ExtractedRecommendation.KeyQuotes(childComplexity), true
	case "ExtractedRecommendation.sentiment":
		if e.complexity.ExtractedRecommendation.Sentiment == nil {
			break
		}

		return e.complexity.ExtractedRecommendation.Sentiment(childComplexity), true
	case "ExtractedRecommendation.strength":
		if e.complexity.ExtractedRecommendation.Strength == nil {
			break
		}

		return e.complexity.ExtractedRecommendation.Strength(childComplexity), true
	case "ExtractedRecommendation.summary":
		if e.complexity.ExtractedRecommendation.Summary == nil {
			break
		}

		return e.complexity.ExtractedRecommendation.Summary(childComplexity), true

	case "ExtractedSkill.category":
		if e.complexity.ExtractedSkill.Category == nil {
			break
		}

		return e.complexity.ExtractedSkill.Category(childComplexity), true
	case "ExtractedSkill.confidence":
		if e.complexity.ExtractedSkill.Confidence == nil {
			break
		}

		return e.complexity.ExtractedSkill.Confidence(childComplexity), true
	case "ExtractedSkill.context":
		if e.complexity.ExtractedSkill.Context == nil {
			break
		}

		return e.complexity.ExtractedSkill.Context(childComplexity), true
	case "ExtractedSkill.mentions":
		if e.complexity.ExtractedSkill.Mentions == nil {
			break
		}

		return e.complexity.ExtractedSkill.Mentions(childComplexity), true
	case "ExtractedSkill.name":
		if e.complexity.ExtractedSkill.Name == nil {
			break
		}

		return e.complexity.ExtractedSkill.Name(childComplexity), true
	case "ExtractedSkill.normalizedName":
		if e.complexity.ExtractedSkill.NormalizedName == nil {
			break
		}

		return e.complexity.ExtractedSkill.NormalizedName(childComplexity), true

	case "ExtractionMetadata.extractedAt":
		if e.complexity.ExtractionMetadata.ExtractedAt == nil {
			break
		}

		return e.complexity.ExtractionMetadata.ExtractedAt(childComplexity), true
	case "ExtractionMetadata.modelVersion":
		if e.complexity.ExtractionMetadata.ModelVersion == nil {
			break
		}

		return e.complexity.ExtractionMetadata.ModelVersion(childComplexity), true
	case "ExtractionMetadata.overallConfidence":
		if e.complexity.ExtractionMetadata.OverallConfidence == nil {
			break
		}

		return e.complexity.ExtractionMetadata.OverallConfidence(childComplexity), true
	case "ExtractionMetadata.processingTimeMs":
		if e.complexity.ExtractionMetadata.ProcessingTimeMs == nil {
			break
		}

		return e.complexity.ExtractionMetadata.ProcessingTimeMs(childComplexity), true
	case "ExtractionMetadata.warnings":
		if e.complexity.ExtractionMetadata.Warnings == nil {
			break
		}

		return e.complexity.ExtractionMetadata.Warnings(childComplexity), true
	case "ExtractionMetadata.warningsCount":
		if e.complexity.ExtractionMetadata.WarningsCount == nil {
			break
		}

		return e.complexity.ExtractionMetadata.WarningsCount(childComplexity), true

	case "File.contentType":
		if e.complexity.File.ContentType == nil {
			break
		}

		return e.complexity.File.ContentType(childComplexity), true
	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true
	case "File.filename":
		if e.complexity.File.Filename == nil {
			break
		}

		return e.complexity.File.Filename(childComplexity), true
	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true
	case "File.sizeBytes":
		if e.complexity.File.SizeBytes == nil {
			break
		}

		return e.complexity.File.SizeBytes(childComplexity), true
	case "File.storageKey":
		if e.complexity.File.StorageKey == nil {
			break
		}

		return e.complexity.File.StorageKey(childComplexity), true
	case "File.user":
		if e.complexity.File.User == nil {
			break
		}

		return e.complexity.File.User(childComplexity), true

	case "FileValidationError.field":
		if e.complexity.FileValidationError.Field == nil {
			break
		}

		return e.complexity.FileValidationError.Field(childComplexity), true
	case "FileValidationError.message":
		if e.complexity.FileValidationError.Message == nil {
			break
		}

		return e.complexity.FileValidationError.Message(childComplexity), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["userId"].(string), args["file"].(graphql.Upload)), true

	case "Query.file":
		if e.complexity.Query.File == nil {
			break
		}

		args, err := ec.field_Query_file_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.File(childComplexity, args["id"].(string)), true
	case "Query.files":
		if e.complexity.Query.Files == nil {
			break
		}

		args, err := ec.field_Query_files_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Files(childComplexity, args["userId"].(string)), true
	case "Query.referenceLetter":
		if e.complexity.Query.ReferenceLetter == nil {
			break
		}

		args, err := ec.field_Query_referenceLetter_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ReferenceLetter(childComplexity, args["id"].(string)), true
	case "Query.referenceLetters":
		if e.complexity.Query.ReferenceLetters == nil {
			break
		}

		args, err := ec.field_Query_referenceLetters_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ReferenceLetters(childComplexity, args["userId"].(string)), true
	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "ReferenceLetter.authorName":
		if e.complexity.ReferenceLetter.AuthorName == nil {
			break
		}

		return e.complexity.ReferenceLetter.AuthorName(childComplexity), true
	case "ReferenceLetter.authorTitle":
		if e.complexity.ReferenceLetter.AuthorTitle == nil {
			break
		}

		return e.complexity.ReferenceLetter.AuthorTitle(childComplexity), true
	case "ReferenceLetter.createdAt":
		if e.complexity.ReferenceLetter.CreatedAt == nil {
			break
		}

		return e.complexity.ReferenceLetter.CreatedAt(childComplexity), true
	case "ReferenceLetter.dateWritten":
		if e.complexity.ReferenceLetter.DateWritten == nil {
			break
		}

		return e.complexity.ReferenceLetter.DateWritten(childComplexity), true
	case "ReferenceLetter.extractedData":
		if e.complexity.ReferenceLetter.ExtractedData == nil {
			break
		}

		return e.complexity.ReferenceLetter.ExtractedData(childComplexity), true
	case "ReferenceLetter.file":
		if e.complexity.ReferenceLetter.File == nil {
			break
		}

		return e.complexity.ReferenceLetter.File(childComplexity), true
	case "ReferenceLetter.id":
		if e.complexity.ReferenceLetter.ID == nil {
			break
		}

		return e.complexity.ReferenceLetter.ID(childComplexity), true
	case "ReferenceLetter.organization":
		if e.complexity.ReferenceLetter.Organization == nil {
			break
		}

		return e.complexity.ReferenceLetter.Organization(childComplexity), true
	case "ReferenceLetter.rawText":
		if e.complexity.ReferenceLetter.RawText == nil {
			break
		}

		return e.complexity.ReferenceLetter.RawText(childComplexity), true
	case "ReferenceLetter.status":
		if e.complexity.ReferenceLetter.Status == nil {
			break
		}

		return e.complexity.ReferenceLetter.Status(childComplexity), true
	case "ReferenceLetter.title":
		if e.complexity.ReferenceLetter.Title == nil {
			break
		}

		return e.complexity.ReferenceLetter.Title(childComplexity), true
	case "ReferenceLetter.updatedAt":
		if e.complexity.ReferenceLetter.UpdatedAt == nil {
			break
		}

		return e.complexity.ReferenceLetter.UpdatedAt(childComplexity), true
	case "ReferenceLetter.user":
		if e.complexity.ReferenceLetter.User == nil {
			break
		}

		return e.complexity.ReferenceLetter.User(childComplexity), true

	case "UploadFileResult.file":
		if e.complexity.UploadFileResult.File == nil {
			break
		}

		return e.complexity.UploadFileResult.File(childComplexity), true
	case "UploadFileResult.referenceLetter":
		if e.complexity.UploadFileResult.ReferenceLetter == nil {
			break
		}

		return e.complexity.UploadFileResult.ReferenceLetter(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true
	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true
	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true
	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true
	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphqls", Input: `# GraphQL schema for Credfolio2

scalar DateTime
scalar JSON
scalar Upload

"""
A user account in the system.
"""
type User {
  id: ID!
  email: String!
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
An uploaded file stored in object storage.
"""
type File {
  id: ID!
  filename: String!
  contentType: String!
  sizeBytes: Int!
  storageKey: String!
  createdAt: DateTime!
  user: User!
}

"""
Processing status of a reference letter.
"""
enum ReferenceLetterStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

# ============================================================================
# Reference Letter Extraction Schema
# ============================================================================

"""
Relationship type between letter author and candidate.
"""
enum AuthorRelationship {
  MANAGER
  COLLEAGUE
  PROFESSOR
  CLIENT
  MENTOR
  OTHER
}

"""
Skill category classification.
"""
enum SkillCategory {
  TECHNICAL
  SOFT
  DOMAIN
}

"""
Recommendation strength level.
"""
enum RecommendationStrength {
  STRONG
  MODERATE
  RESERVED
}

"""
Author details extracted from a reference letter.
"""
type ExtractedAuthor {
  """The author's full name."""
  name: String!
  """The author's job title or position."""
  title: String
  """The organization where the author works."""
  organization: String
  """The relationship type between author and candidate."""
  relationship: AuthorRelationship!
  """Additional details about the relationship (e.g., 'Direct supervisor for 3 years')."""
  relationshipDetails: String
  """Confidence score for this extraction (0.0 to 1.0)."""
  confidence: Float!
}

"""
A skill mentioned in a reference letter.
"""
type ExtractedSkill {
  """The skill name as it appears in the letter."""
  name: String!
  """Normalized skill name for aggregation (e.g., 'JavaScript' and 'JS' both become 'javascript')."""
  normalizedName: String!
  """The category of skill."""
  category: SkillCategory!
  """Number of times this skill was mentioned in the letter."""
  mentions: Int!
  """Contextual quotes where the skill was mentioned."""
  context: [String!]
  """Confidence score for this extraction (0.0 to 1.0)."""
  confidence: Float!
}

"""
A quality or trait mentioned in a reference letter.
"""
type ExtractedQuality {
  """The quality or trait name."""
  trait: String!
  """Supporting evidence or quotes from the letter."""
  evidence: [String!]
  """Confidence score for this extraction (0.0 to 1.0)."""
  confidence: Float!
}

"""
An accomplishment cited in a reference letter.
"""
type ExtractedAccomplishment {
  """Description of the accomplishment."""
  description: String!
  """The impact or result of the accomplishment."""
  impact: String
  """When the accomplishment occurred (e.g., '2024', 'Q3 2023')."""
  timeframe: String
  """Confidence score for this extraction (0.0 to 1.0)."""
  confidence: Float!
}

"""
Overall recommendation assessment from a reference letter.
"""
type ExtractedRecommendation {
  """The overall strength of the recommendation."""
  strength: RecommendationStrength!
  """Sentiment score from -1.0 (negative) to 1.0 (positive)."""
  sentiment: Float!
  """Key quotes that demonstrate the recommendation strength."""
  keyQuotes: [String!]
  """Brief summary of the recommendation."""
  summary: String
  """Confidence score for this extraction (0.0 to 1.0)."""
  confidence: Float!
}

"""
Metadata about the extraction process.
"""
type ExtractionMetadata {
  """When the extraction was performed."""
  extractedAt: DateTime!
  """The LLM model version used for extraction."""
  modelVersion: String!
  """Overall confidence score for the entire extraction (0.0 to 1.0)."""
  overallConfidence: Float!
  """Time taken to process the extraction in milliseconds."""
  processingTimeMs: Int
  """Number of warnings generated during extraction."""
  warningsCount: Int!
  """Warning messages from the extraction process."""
  warnings: [String!]
}

"""
Structured data extracted from a reference letter.
"""
type ExtractedLetterData {
  """Details about the letter's author."""
  author: ExtractedAuthor!
  """Skills mentioned in the letter."""
  skills: [ExtractedSkill!]!
  """Qualities and traits mentioned in the letter."""
  qualities: [ExtractedQuality!]!
  """Accomplishments cited in the letter."""
  accomplishments: [ExtractedAccomplishment!]!
  """Overall recommendation assessment."""
  recommendation: ExtractedRecommendation!
  """Metadata about the extraction process."""
  metadata: ExtractionMetadata!
}

# ============================================================================
# Main Types
# ============================================================================

"""
A reference letter with extracted data.
"""
type ReferenceLetter {
  id: ID!
  title: String
  authorName: String
  authorTitle: String
  organization: String
  dateWritten: DateTime
  rawText: String
  """Structured data extracted from the letter by LLM processing."""
  extractedData: ExtractedLetterData
  status: ReferenceLetterStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  file: File
}

type Query {
  """
  Get a user by ID.
  """
  user(id: ID!): User

  """
  Get a file by ID.
  """
  file(id: ID!): File

  """
  Get all files for a user.
  """
  files(userId: ID!): [File!]!

  """
  Get a reference letter by ID.
  """
  referenceLetter(id: ID!): ReferenceLetter

  """
  Get all reference letters for a user.
  """
  referenceLetters(userId: ID!): [ReferenceLetter!]!
}

# ============================================================================
# Mutations
# ============================================================================

"""
Result of a file upload operation.
"""
type UploadFileResult {
  """The uploaded file metadata."""
  file: File!
  """The reference letter created for processing."""
  referenceLetter: ReferenceLetter!
}

"""
Error returned when file validation fails.
"""
type FileValidationError {
  """Error message describing the validation failure."""
  message: String!
  """The field that failed validation (e.g., 'contentType', 'size')."""
  field: String!
}

"""
Union type for upload result - either success or validation error.
"""
union UploadFileResponse = UploadFileResult | FileValidationError

type Mutation {
  """
  Upload a reference letter file for processing.
  Accepts PDF, DOCX, or TXT files.
  Creates a file record and queues the document for LLM extraction.
  """
  uploadFile(
    """The user ID uploading the file."""
    userId: ID!
    """The file to upload (PDF, DOCX, or TXT only)."""
    file: Upload!
  ): UploadFileResponse!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_uploadFile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["userId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "file", ec.unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload)
	if err != nil {
		return nil, err
	}
	args["file"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_file_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_files_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_referenceLetter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_referenceLetters_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ExtractedAccomplishment_description(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAccomplishment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAccomplishment_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedAccomplishment_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAccomplishment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAccomplishment_impact(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAccomplishment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAccomplishment_impact,
		func(ctx context.Context) (any, error) {
			return obj.Impact, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedAccomplishment_impact(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAccomplishment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAccomplishment_timeframe(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAccomplishment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAccomplishment_timeframe,
		func(ctx context.Context) (any, error) {
			return obj.Timeframe, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedAccomplishment_timeframe(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAccomplishment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAccomplishment_confidence(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAccomplishment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAccomplishment_confidence,
		func(ctx context.Context) (any, error) {
			return obj.Confidence, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedAccomplishment_confidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAccomplishment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAuthor_name(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAuthor) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAuthor_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedAuthor_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAuthor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAuthor_title(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAuthor) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAuthor_title,
		func(ctx context.Context) (any, error) {
			return obj.Title, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedAuthor_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAuthor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAuthor_organization(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAuthor) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAuthor_organization,
		func(ctx context.Context) (any, error) {
			return obj.Organization, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedAuthor_organization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAuthor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAuthor_relationship(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAuthor) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAuthor_relationship,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ExtractedAuthor().Relationship(ctx, obj)
		},
		nil,
		ec.marshalNAuthorRelationship2backendᚋinternalᚋdomainᚐAuthorRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedAuthor_relationship(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAuthor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuthorRelationship does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAuthor_relationshipDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAuthor) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAuthor_relationshipDetails,
		func(ctx context.Context) (any, error) {
			return obj.RelationshipDetails, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedAuthor_relationshipDetails(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAuthor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedAuthor_confidence(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedAuthor) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedAuthor_confidence,
		func(ctx context.Context) (any, error) {
			return obj.Confidence, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedAuthor_confidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedAuthor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedLetterData_author(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedLetterData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedLetterData_author,
		func(ctx context.Context) (any, error) {
			return obj.Author, nil
		},
		nil,
		ec.marshalNExtractedAuthor2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedAuthor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedLetterData_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedLetterData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ExtractedAuthor_name(ctx, field)
			case "title":
				return ec.fieldContext_ExtractedAuthor_title(ctx, field)
			case "organization":
				return ec.fieldContext_ExtractedAuthor_organization(ctx, field)
			case "relationship":
				return ec.fieldContext_ExtractedAuthor_relationship(ctx, field)
			case "relationshipDetails":
				return ec.fieldContext_ExtractedAuthor_relationshipDetails(ctx, field)
			case "confidence":
				return ec.fieldContext_ExtractedAuthor_confidence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExtractedAuthor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedLetterData_skills(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedLetterData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedLetterData_skills,
		func(ctx context.Context) (any, error) {
			return obj.Skills, nil
		},
		nil,
		ec.marshalNExtractedSkill2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedSkillᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedLetterData_skills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedLetterData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ExtractedSkill_name(ctx, field)
			case "normalizedName":
				return ec.fieldContext_ExtractedSkill_normalizedName(ctx, field)
			case "category":
				return ec.fieldContext_ExtractedSkill_category(ctx, field)
			case "mentions":
				return ec.fieldContext_ExtractedSkill_mentions(ctx, field)
			case "context":
				return ec.fieldContext_ExtractedSkill_context(ctx, field)
			case "confidence":
				return ec.fieldContext_ExtractedSkill_confidence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExtractedSkill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedLetterData_qualities(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedLetterData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedLetterData_qualities,
		func(ctx context.Context) (any, error) {
			return obj.Qualities, nil
		},
		nil,
		ec.marshalNExtractedQuality2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedQualityᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedLetterData_qualities(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedLetterData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "trait":
				return ec.fieldContext_ExtractedQuality_trait(ctx, field)
			case "evidence":
				return ec.fieldContext_ExtractedQuality_evidence(ctx, field)
			case "confidence":
				return ec.fieldContext_ExtractedQuality_confidence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExtractedQuality", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedLetterData_accomplishments(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedLetterData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedLetterData_accomplishments,
		func(ctx context.Context) (any, error) {
			return obj.Accomplishments, nil
		},
		nil,
		ec.marshalNExtractedAccomplishment2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedAccomplishmentᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedLetterData_accomplishments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedLetterData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext_ExtractedAccomplishment_description(ctx, field)
			case "impact":
				return ec.fieldContext_ExtractedAccomplishment_impact(ctx, field)
			case "timeframe":
				return ec.fieldContext_ExtractedAccomplishment_timeframe(ctx, field)
			case "confidence":
				return ec.fieldContext_ExtractedAccomplishment_confidence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExtractedAccomplishment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedLetterData_recommendation(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedLetterData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedLetterData_recommendation,
		func(ctx context.Context) (any, error) {
			return obj.Recommendation, nil
		},
		nil,
		ec.marshalNExtractedRecommendation2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedRecommendation,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedLetterData_recommendation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedLetterData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "strength":
				return ec.fieldContext_ExtractedRecommendation_strength(ctx, field)
			case "sentiment":
				return ec.fieldContext_ExtractedRecommendation_sentiment(ctx, field)
			case "keyQuotes":
				return ec.fieldContext_ExtractedRecommendation_keyQuotes(ctx, field)
			case "summary":
				return ec.fieldContext_ExtractedRecommendation_summary(ctx, field)
			case "confidence":
				return ec.fieldContext_ExtractedRecommendation_confidence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExtractedRecommendation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedLetterData_metadata(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedLetterData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedLetterData_metadata,
		func(ctx context.Context) (any, error) {
			return obj.Metadata, nil
		},
		nil,
		ec.marshalNExtractionMetadata2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractionMetadata,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedLetterData_metadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedLetterData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "extractedAt":
				return ec.fieldContext_ExtractionMetadata_extractedAt(ctx, field)
			case "modelVersion":
				return ec.fieldContext_ExtractionMetadata_modelVersion(ctx, field)
			case "overallConfidence":
				return ec.fieldContext_ExtractionMetadata_overallConfidence(ctx, field)
			case "processingTimeMs":
				return ec.fieldContext_ExtractionMetadata_processingTimeMs(ctx, field)
			case "warningsCount":
				return ec.fieldContext_ExtractionMetadata_warningsCount(ctx, field)
			case "warnings":
				return ec.fieldContext_ExtractionMetadata_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExtractionMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedQuality_trait(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedQuality) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedQuality_trait,
		func(ctx context.Context) (any, error) {
			return obj.Trait, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedQuality_trait(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedQuality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedQuality_evidence(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedQuality) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedQuality_evidence,
		func(ctx context.Context) (any, error) {
			return obj.Evidence, nil
		},
		nil,
		ec.marshalOString2ᚕstringᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedQuality_evidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedQuality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedQuality_confidence(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedQuality) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedQuality_confidence,
		func(ctx context.Context) (any, error) {
			return obj.Confidence, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedQuality_confidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedQuality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedRecommendation_strength(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedRecommendation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedRecommendation_strength,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ExtractedRecommendation().Strength(ctx, obj)
		},
		nil,
		ec.marshalNRecommendationStrength2backendᚋinternalᚋdomainᚐRecommendationStrength,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedRecommendation_strength(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedRecommendation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RecommendationStrength does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedRecommendation_sentiment(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedRecommendation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedRecommendation_sentiment,
		func(ctx context.Context) (any, error) {
			return obj.Sentiment, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedRecommendation_sentiment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedRecommendation_keyQuotes(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedRecommendation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedRecommendation_keyQuotes,
		func(ctx context.Context) (any, error) {
			return obj.KeyQuotes, nil
		},
		nil,
		ec.marshalOString2ᚕstringᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedRecommendation_keyQuotes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedRecommendation_summary(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedRecommendation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedRecommendation_summary,
		func(ctx context.Context) (any, error) {
			return obj.Summary, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedRecommendation_summary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedRecommendation_confidence(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedRecommendation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedRecommendation_confidence,
		func(ctx context.Context) (any, error) {
			return obj.Confidence, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedRecommendation_confidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedSkill_name(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedSkill) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedSkill_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedSkill_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedSkill_normalizedName(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedSkill) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedSkill_normalizedName,
		func(ctx context.Context) (any, error) {
			return obj.NormalizedName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedSkill_normalizedName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedSkill_category(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedSkill) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedSkill_category,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ExtractedSkill().Category(ctx, obj)
		},
		nil,
		ec.marshalNSkillCategory2backendᚋinternalᚋdomainᚐSkillCategory,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedSkill_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedSkill",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SkillCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedSkill_mentions(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedSkill) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedSkill_mentions,
		func(ctx context.Context) (any, error) {
			return obj.Mentions, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedSkill_mentions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedSkill_context(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedSkill) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedSkill_context,
		func(ctx context.Context) (any, error) {
			return obj.Context, nil
		},
		nil,
		ec.marshalOString2ᚕstringᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractedSkill_context(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractedSkill_confidence(ctx context.Context, field graphql.CollectedField, obj *model.ExtractedSkill) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractedSkill_confidence,
		func(ctx context.Context) (any, error) {
			return obj.Confidence, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractedSkill_confidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractedSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractionMetadata_extractedAt(ctx context.Context, field graphql.CollectedField, obj *model.ExtractionMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractionMetadata_extractedAt,
		func(ctx context.Context) (any, error) {
			return obj.ExtractedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractionMetadata_extractedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractionMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractionMetadata_modelVersion(ctx context.Context, field graphql.CollectedField, obj *model.ExtractionMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractionMetadata_modelVersion,
		func(ctx context.Context) (any, error) {
			return obj.ModelVersion, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractionMetadata_modelVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractionMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractionMetadata_overallConfidence(ctx context.Context, field graphql.CollectedField, obj *model.ExtractionMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractionMetadata_overallConfidence,
		func(ctx context.Context) (any, error) {
			return obj.OverallConfidence, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractionMetadata_overallConfidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractionMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractionMetadata_processingTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.ExtractionMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractionMetadata_processingTimeMs,
		func(ctx context.Context) (any, error) {
			return obj.ProcessingTimeMs, nil
		},
		nil,
		ec.marshalOInt2ᚖint,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractionMetadata_processingTimeMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractionMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractionMetadata_warningsCount(ctx context.Context, field graphql.CollectedField, obj *model.ExtractionMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractionMetadata_warningsCount,
		func(ctx context.Context) (any, error) {
			return obj.WarningsCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExtractionMetadata_warningsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractionMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExtractionMetadata_warnings(ctx context.Context, field graphql.CollectedField, obj *model.ExtractionMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExtractionMetadata_warnings,
		func(ctx context.Context) (any, error) {
			return obj.Warnings, nil
		},
		nil,
		ec.marshalOString2ᚕstringᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExtractionMetadata_warnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExtractionMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_id(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_filename(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_filename,
		func(ctx context.Context) (any, error) {
			return obj.Filename, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_filename(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_contentType(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_contentType,
		func(ctx context.Context) (any, error) {
			return obj.ContentType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_contentType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_sizeBytes(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_sizeBytes,
		func(ctx context.Context) (any, error) {
			return obj.SizeBytes, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_sizeBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_storageKey(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_storageKey,
		func(ctx context.Context) (any, error) {
			return obj.StorageKey, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_storageKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_user(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNUser2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileValidationError_message(ctx context.Context, field graphql.CollectedField, obj *model.FileValidationError) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileValidationError_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileValidationError_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileValidationError_field(ctx context.Context, field graphql.CollectedField, obj *model.FileValidationError) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileValidationError_field,
		func(ctx context.Context) (any, error) {
			return obj.Field, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileValidationError_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadFile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_uploadFile,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UploadFile(ctx, fc.Args["userId"].(string), fc.Args["file"].(graphql.Upload))
		},
		nil,
		ec.marshalNUploadFileResponse2backendᚋinternalᚋgraphqlᚋmodelᚐUploadFileResponse,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_uploadFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UploadFileResponse does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadFile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_user,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().User(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOUser2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐUser,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_file(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_file,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().File(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOFile2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFile,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_file(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_File_id(ctx, field)
			case "filename":
				return ec.fieldContext_File_filename(ctx, field)
			case "contentType":
				return ec.fieldContext_File_contentType(ctx, field)
			case "sizeBytes":
				return ec.fieldContext_File_sizeBytes(ctx, field)
			case "storageKey":
				return ec.fieldContext_File_storageKey(ctx, field)
			case "createdAt":
				return ec.fieldContext_File_createdAt(ctx, field)
			case "user":
				return ec.fieldContext_File_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_file_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_files(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_files,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Files(ctx, fc.Args["userId"].(string))
		},
		nil,
		ec.marshalNFile2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFileᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_File_id(ctx, field)
			case "filename":
				return ec.fieldContext_File_filename(ctx, field)
			case "contentType":
				return ec.fieldContext_File_contentType(ctx, field)
			case "sizeBytes":
				return ec.fieldContext_File_sizeBytes(ctx, field)
			case "storageKey":
				return ec.fieldContext_File_storageKey(ctx, field)
			case "createdAt":
				return ec.fieldContext_File_createdAt(ctx, field)
			case "user":
				return ec.fieldContext_File_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_referenceLetter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_referenceLetter,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ReferenceLetter(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOReferenceLetter2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetter,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_referenceLetter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ReferenceLetter_id(ctx, field)
			case "title":
				return ec.fieldContext_ReferenceLetter_title(ctx, field)
			case "authorName":
				return ec.fieldContext_ReferenceLetter_authorName(ctx, field)
			case "authorTitle":
				return ec.fieldContext_ReferenceLetter_authorTitle(ctx, field)
			case "organization":
				return ec.fieldContext_ReferenceLetter_organization(ctx, field)
			case "dateWritten":
				return ec.fieldContext_ReferenceLetter_dateWritten(ctx, field)
			case "rawText":
				return ec.fieldContext_ReferenceLetter_rawText(ctx, field)
			case "extractedData":
				return ec.fieldContext_ReferenceLetter_extractedData(ctx, field)
			case "status":
				return ec.fieldContext_ReferenceLetter_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_ReferenceLetter_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ReferenceLetter_updatedAt(ctx, field)
			case "user":
				return ec.fieldContext_ReferenceLetter_user(ctx, field)
			case "file":
				return ec.fieldContext_ReferenceLetter_file(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReferenceLetter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_referenceLetter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_referenceLetters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_referenceLetters,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ReferenceLetters(ctx, fc.Args["userId"].(string))
		},
		nil,
		ec.marshalNReferenceLetter2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetterᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_referenceLetters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ReferenceLetter_id(ctx, field)
			case "title":
				return ec.fieldContext_ReferenceLetter_title(ctx, field)
			case "authorName":
				return ec.fieldContext_ReferenceLetter_authorName(ctx, field)
			case "authorTitle":
				return ec.fieldContext_ReferenceLetter_authorTitle(ctx, field)
			case "organization":
				return ec.fieldContext_ReferenceLetter_organization(ctx, field)
			case "dateWritten":
				return ec.fieldContext_ReferenceLetter_dateWritten(ctx, field)
			case "rawText":
				return ec.fieldContext_ReferenceLetter_rawText(ctx, field)
			case "extractedData":
				return ec.fieldContext_ReferenceLetter_extractedData(ctx, field)
			case "status":
				return ec.fieldContext_ReferenceLetter_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_ReferenceLetter_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ReferenceLetter_updatedAt(ctx, field)
			case "user":
				return ec.fieldContext_ReferenceLetter_user(ctx, field)
			case "file":
				return ec.fieldContext_ReferenceLetter_file(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReferenceLetter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_referenceLetters_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_id(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_title(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_title,
		func(ctx context.Context) (any, error) {
			return obj.Title, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_authorName(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_authorName,
		func(ctx context.Context) (any, error) {
			return obj.AuthorName, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_authorName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_authorTitle(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_authorTitle,
		func(ctx context.Context) (any, error) {
			return obj.AuthorTitle, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_authorTitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_organization(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_organization,
		func(ctx context.Context) (any, error) {
			return obj.Organization, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_organization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_dateWritten(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_dateWritten,
		func(ctx context.Context) (any, error) {
			return obj.DateWritten, nil
		},
		nil,
		ec.marshalODateTime2ᚖtimeᚐTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_dateWritten(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_rawText(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_rawText,
		func(ctx context.Context) (any, error) {
			return obj.RawText, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_rawText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_extractedData(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_extractedData,
		func(ctx context.Context) (any, error) {
			return obj.ExtractedData, nil
		},
		nil,
		ec.marshalOExtractedLetterData2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedLetterData,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_extractedData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_ExtractedLetterData_author(ctx, field)
			case "skills":
				return ec.fieldContext_ExtractedLetterData_skills(ctx, field)
			case "qualities":
				return ec.fieldContext_ExtractedLetterData_qualities(ctx, field)
			case "accomplishments":
				return ec.fieldContext_ExtractedLetterData_accomplishments(ctx, field)
			case "recommendation":
				return ec.fieldContext_ExtractedLetterData_recommendation(ctx, field)
			case "metadata":
				return ec.fieldContext_ExtractedLetterData_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExtractedLetterData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_status(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNReferenceLetterStatus2backendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetterStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ReferenceLetterStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_user(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNUser2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReferenceLetter_file(ctx context.Context, field graphql.CollectedField, obj *model.ReferenceLetter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReferenceLetter_file,
		func(ctx context.Context) (any, error) {
			return obj.File, nil
		},
		nil,
		ec.marshalOFile2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFile,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReferenceLetter_file(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReferenceLetter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_File_id(ctx, field)
			case "filename":
				return ec.fieldContext_File_filename(ctx, field)
			case "contentType":
				return ec.fieldContext_File_contentType(ctx, field)
			case "sizeBytes":
				return ec.fieldContext_File_sizeBytes(ctx, field)
			case "storageKey":
				return ec.fieldContext_File_storageKey(ctx, field)
			case "createdAt":
				return ec.fieldContext_File_createdAt(ctx, field)
			case "user":
				return ec.fieldContext_File_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadFileResult_file(ctx context.Context, field graphql.CollectedField, obj *model.UploadFileResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UploadFileResult_file,
		func(ctx context.Context) (any, error) {
			return obj.File, nil
		},
		nil,
		ec.marshalNFile2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFile,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UploadFileResult_file(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadFileResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_File_id(ctx, field)
			case "filename":
				return ec.fieldContext_File_filename(ctx, field)
			case "contentType":
				return ec.fieldContext_File_contentType(ctx, field)
			case "sizeBytes":
				return ec.fieldContext_File_sizeBytes(ctx, field)
			case "storageKey":
				return ec.fieldContext_File_storageKey(ctx, field)
			case "createdAt":
				return ec.fieldContext_File_createdAt(ctx, field)
			case "user":
				return ec.fieldContext_File_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadFileResult_referenceLetter(ctx context.Context, field graphql.CollectedField, obj *model.UploadFileResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UploadFileResult_referenceLetter,
		func(ctx context.Context) (any, error) {
			return obj.ReferenceLetter, nil
		},
		nil,
		ec.marshalNReferenceLetter2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetter,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UploadFileResult_referenceLetter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadFileResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ReferenceLetter_id(ctx, field)
			case "title":
				return ec.fieldContext_ReferenceLetter_title(ctx, field)
			case "authorName":
				return ec.fieldContext_ReferenceLetter_authorName(ctx, field)
			case "authorTitle":
				return ec.fieldContext_ReferenceLetter_authorTitle(ctx, field)
			case "organization":
				return ec.fieldContext_ReferenceLetter_organization(ctx, field)
			case "dateWritten":
				return ec.fieldContext_ReferenceLetter_dateWritten(ctx, field)
			case "rawText":
				return ec.fieldContext_ReferenceLetter_rawText(ctx, field)
			case "extractedData":
				return ec.fieldContext_ReferenceLetter_extractedData(ctx, field)
			case "status":
				return ec.fieldContext_ReferenceLetter_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_ReferenceLetter_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ReferenceLetter_updatedAt(ctx, field)
			case "user":
				return ec.fieldContext_ReferenceLetter_user(ctx, field)
			case "file":
				return ec.fieldContext_ReferenceLetter_file(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReferenceLetter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_email,
		func(ctx context.Context) (any, error) {
			return obj.Email, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _UploadFileResponse(ctx context.Context, sel ast.SelectionSet, obj model.UploadFileResponse) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UploadFileResult:
		return ec._UploadFileResult(ctx, sel, &obj)
	case *model.UploadFileResult:
		if obj == nil {
			return graphql.Null
		}
		return ec._UploadFileResult(ctx, sel, obj)
	case model.FileValidationError:
		return ec._FileValidationError(ctx, sel, &obj)
	case *model.FileValidationError:
		if obj == nil {
			return graphql.Null
		}
		return ec._FileValidationError(ctx, sel, obj)
	default:
		if typedObj, ok := obj.(graphql.Marshaler); ok {
			return typedObj
		} else {
			panic(fmt.Errorf("unexpected type %T; non-generated variants of UploadFileResponse must implement graphql.Marshaler", obj))
		}
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var extractedAccomplishmentImplementors = []string{"ExtractedAccomplishment"}

func (ec *executionContext) _ExtractedAccomplishment(ctx context.Context, sel ast.SelectionSet, obj *model.ExtractedAccomplishment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, extractedAccomplishmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExtractedAccomplishment")
		case "description":
			out.Values[i] = ec._ExtractedAccomplishment_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "impact":
			out.Values[i] = ec._ExtractedAccomplishment_impact(ctx, field, obj)
		case "timeframe":
			out.Values[i] = ec._ExtractedAccomplishment_timeframe(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._ExtractedAccomplishment_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var extractedAuthorImplementors = []string{"ExtractedAuthor"}

func (ec *executionContext) _ExtractedAuthor(ctx context.Context, sel ast.SelectionSet, obj *model.ExtractedAuthor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, extractedAuthorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExtractedAuthor")
		case "name":
			out.Values[i] = ec._ExtractedAuthor_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._ExtractedAuthor_title(ctx, field, obj)
		case "organization":
			out.Values[i] = ec._ExtractedAuthor_organization(ctx, field, obj)
		case "relationship":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExtractedAuthor_relationship(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "relationshipDetails":
			out.Values[i] = ec._ExtractedAuthor_relationshipDetails(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._ExtractedAuthor_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var extractedLetterDataImplementors = []string{"ExtractedLetterData"}

func (ec *executionContext) _ExtractedLetterData(ctx context.Context, sel ast.SelectionSet, obj *model.ExtractedLetterData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, extractedLetterDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExtractedLetterData")
		case "author":
			out.Values[i] = ec._ExtractedLetterData_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "skills":
			out.Values[i] = ec._ExtractedLetterData_skills(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "qualities":
			out.Values[i] = ec._ExtractedLetterData_qualities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "accomplishments":
			out.Values[i] = ec._ExtractedLetterData_accomplishments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recommendation":
			out.Values[i] = ec._ExtractedLetterData_recommendation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "metadata":
			out.Values[i] = ec._ExtractedLetterData_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var extractedQualityImplementors = []string{"ExtractedQuality"}

func (ec *executionContext) _ExtractedQuality(ctx context.Context, sel ast.SelectionSet, obj *model.ExtractedQuality) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, extractedQualityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExtractedQuality")
		case "trait":
			out.Values[i] = ec._ExtractedQuality_trait(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "evidence":
			out.Values[i] = ec._ExtractedQuality_evidence(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._ExtractedQuality_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var extractedRecommendationImplementors = []string{"ExtractedRecommendation"}

func (ec *executionContext) _ExtractedRecommendation(ctx context.Context, sel ast.SelectionSet, obj *model.ExtractedRecommendation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, extractedRecommendationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExtractedRecommendation")
		case "strength":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExtractedRecommendation_strength(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sentiment":
			out.Values[i] = ec._ExtractedRecommendation_sentiment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "keyQuotes":
			out.Values[i] = ec._ExtractedRecommendation_keyQuotes(ctx, field, obj)
		case "summary":
			out.Values[i] = ec._ExtractedRecommendation_summary(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._ExtractedRecommendation_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var extractedSkillImplementors = []string{"ExtractedSkill"}

func (ec *executionContext) _ExtractedSkill(ctx context.Context, sel ast.SelectionSet, obj *model.ExtractedSkill) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, extractedSkillImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExtractedSkill")
		case "name":
			out.Values[i] = ec._ExtractedSkill_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "normalizedName":
			out.Values[i] = ec._ExtractedSkill_normalizedName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "category":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExtractedSkill_category(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mentions":
			out.Values[i] = ec._ExtractedSkill_mentions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "context":
			out.Values[i] = ec._ExtractedSkill_context(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._ExtractedSkill_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var extractionMetadataImplementors = []string{"ExtractionMetadata"}

func (ec *executionContext) _ExtractionMetadata(ctx context.Context, sel ast.SelectionSet, obj *model.ExtractionMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, extractionMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExtractionMetadata")
		case "extractedAt":
			out.Values[i] = ec._ExtractionMetadata_extractedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modelVersion":
			out.Values[i] = ec._ExtractionMetadata_modelVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "overallConfidence":
			out.Values[i] = ec._ExtractionMetadata_overallConfidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processingTimeMs":
			out.Values[i] = ec._ExtractionMetadata_processingTimeMs(ctx, field, obj)
		case "warningsCount":
			out.Values[i] = ec._ExtractionMetadata_warningsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "warnings":
			out.Values[i] = ec._ExtractionMetadata_warnings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileImplementors = []string{"File"}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *model.File) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "id":
			out.Values[i] = ec._File_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filename":
			out.Values[i] = ec._File_filename(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "contentType":
			out.Values[i] = ec._File_contentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sizeBytes":
			out.Values[i] = ec._File_sizeBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "storageKey":
			out.Values[i] = ec._File_storageKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._File_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._File_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileValidationErrorImplementors = []string{"FileValidationError", "UploadFileResponse"}

func (ec *executionContext) _FileValidationError(ctx context.Context, sel ast.SelectionSet, obj *model.FileValidationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileValidationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileValidationError")
		case "message":
			out.Values[i] = ec._FileValidationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._FileValidationError_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "uploadFile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadFile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "file":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_file(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_files(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "referenceLetter":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_referenceLetter(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "referenceLetters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_referenceLetters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var referenceLetterImplementors = []string{"ReferenceLetter"}

func (ec *executionContext) _ReferenceLetter(ctx context.Context, sel ast.SelectionSet, obj *model.ReferenceLetter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, referenceLetterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReferenceLetter")
		case "id":
			out.Values[i] = ec._ReferenceLetter_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._ReferenceLetter_title(ctx, field, obj)
		case "authorName":
			out.Values[i] = ec._ReferenceLetter_authorName(ctx, field, obj)
		case "authorTitle":
			out.Values[i] = ec._ReferenceLetter_authorTitle(ctx, field, obj)
		case "organization":
			out.Values[i] = ec._ReferenceLetter_organization(ctx, field, obj)
		case "dateWritten":
			out.Values[i] = ec._ReferenceLetter_dateWritten(ctx, field, obj)
		case "rawText":
			out.Values[i] = ec._ReferenceLetter_rawText(ctx, field, obj)
		case "extractedData":
			out.Values[i] = ec._ReferenceLetter_extractedData(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ReferenceLetter_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ReferenceLetter_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ReferenceLetter_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._ReferenceLetter_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "file":
			out.Values[i] = ec._ReferenceLetter_file(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uploadFileResultImplementors = []string{"UploadFileResult", "UploadFileResponse"}

func (ec *executionContext) _UploadFileResult(ctx context.Context, sel ast.SelectionSet, obj *model.UploadFileResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uploadFileResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UploadFileResult")
		case "file":
			out.Values[i] = ec._UploadFileResult_file(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "referenceLetter":
			out.Values[i] = ec._UploadFileResult_referenceLetter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAuthorRelationship2backendᚋinternalᚋdomainᚐAuthorRelationship(ctx context.Context, v any) (domain.AuthorRelationship, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := domain.AuthorRelationship(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAuthorRelationship2backendᚋinternalᚋdomainᚐAuthorRelationship(ctx context.Context, sel ast.SelectionSet, v domain.AuthorRelationship) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDateTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNExtractedAccomplishment2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedAccomplishmentᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ExtractedAccomplishment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExtractedAccomplishment2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedAccomplishment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExtractedAccomplishment2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedAccomplishment(ctx context.Context, sel ast.SelectionSet, v *model.ExtractedAccomplishment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExtractedAccomplishment(ctx, sel, v)
}

func (ec *executionContext) marshalNExtractedAuthor2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedAuthor(ctx context.Context, sel ast.SelectionSet, v *model.ExtractedAuthor) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExtractedAuthor(ctx, sel, v)
}

func (ec *executionContext) marshalNExtractedQuality2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedQualityᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ExtractedQuality) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExtractedQuality2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedQuality(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExtractedQuality2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedQuality(ctx context.Context, sel ast.SelectionSet, v *model.ExtractedQuality) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExtractedQuality(ctx, sel, v)
}

func (ec *executionContext) marshalNExtractedRecommendation2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedRecommendation(ctx context.Context, sel ast.SelectionSet, v *model.ExtractedRecommendation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExtractedRecommendation(ctx, sel, v)
}

func (ec *executionContext) marshalNExtractedSkill2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedSkillᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ExtractedSkill) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExtractedSkill2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExtractedSkill2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedSkill(ctx context.Context, sel ast.SelectionSet, v *model.ExtractedSkill) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExtractedSkill(ctx, sel, v)
}

func (ec *executionContext) marshalNExtractionMetadata2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractionMetadata(ctx context.Context, sel ast.SelectionSet, v *model.ExtractionMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExtractionMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNFile2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFileᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.File) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFile2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFile2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFile(ctx context.Context, sel ast.SelectionSet, v *model.File) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNRecommendationStrength2backendᚋinternalᚋdomainᚐRecommendationStrength(ctx context.Context, v any) (domain.RecommendationStrength, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := domain.RecommendationStrength(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRecommendationStrength2backendᚋinternalᚋdomainᚐRecommendationStrength(ctx context.Context, sel ast.SelectionSet, v domain.RecommendationStrength) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNReferenceLetter2ᚕᚖbackendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ReferenceLetter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReferenceLetter2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReferenceLetter2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetter(ctx context.Context, sel ast.SelectionSet, v *model.ReferenceLetter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReferenceLetter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNReferenceLetterStatus2backendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetterStatus(ctx context.Context, v any) (model.ReferenceLetterStatus, error) {
	var res model.ReferenceLetterStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNReferenceLetterStatus2backendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetterStatus(ctx context.Context, sel ast.SelectionSet, v model.ReferenceLetterStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSkillCategory2backendᚋinternalᚋdomainᚐSkillCategory(ctx context.Context, v any) (domain.SkillCategory, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := domain.SkillCategory(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSkillCategory2backendᚋinternalᚋdomainᚐSkillCategory(ctx context.Context, sel ast.SelectionSet, v domain.SkillCategory) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, v any) (graphql.Upload, error) {
	res, err := graphql.UnmarshalUpload(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, sel ast.SelectionSet, v graphql.Upload) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalUpload(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUploadFileResponse2backendᚋinternalᚋgraphqlᚋmodelᚐUploadFileResponse(ctx context.Context, sel ast.SelectionSet, v model.UploadFileResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UploadFileResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODateTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOExtractedLetterData2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐExtractedLetterData(ctx context.Context, sel ast.SelectionSet, v *model.ExtractedLetterData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ExtractedLetterData(ctx, sel, v)
}

func (ec *executionContext) marshalOFile2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐFile(ctx context.Context, sel ast.SelectionSet, v *model.File) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOReferenceLetter2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐReferenceLetter(ctx context.Context, sel ast.SelectionSet, v *model.ReferenceLetter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ReferenceLetter(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUser2ᚖbackendᚋinternalᚋgraphqlᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
